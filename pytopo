#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
pytopo: show topographic maps using data files from Topo! CD
to generate a map at the specified coordinates.
Home page and more documentation: http://shallowsky.com/software/topo/

Copyright 2005 - 2015 by Akkana Peck, akkana@shallowsky.com
Please feel free to use, distribute or modify this program
under the terms of the GPL v2 or, at your option, a later GPL version.
I'd appreciate hearing about it if you make any changes.

Finding zero-length files:
 find Maps/opencyclemap/13 -size 0
 cd Maps/opencyclemap/13/1429
 #wget http://a.andy.sandbox.cloudmade.com/tiles/cycle/13/1429/3230.png
 wget http://b.tile.opencyclemap.org/cycle/13/1473/3236.png

Downloading your own file collection (faster than doing it interactively):
cd Maps/opencyclemap
  foreach level (*)
    cd Maps/opencyclemap/$level
    foreach dir (*)
      cd Maps/opencyclemap/$level/$dir
        foreach fil (`find . -size 0`)
          echo $dir/$fil
          rm $fil
          #wget http://a.andy.sandbox.cloudmade.com/tiles/cycle/$level/$dir/$fil
          wget http://b.tile.opencyclemap.org/cycle/$level/$dir/$fil
        end
    end
  end
end

TODO: allow configuration of colors, line thickness etc.
"""

# We will do all calculations in decimal degrees,
# but take inputs in deg.decimal_minutes.

Version = "1.2"
VersionString = "PyTopo Version %s by Akkana Peck" % Version

import sys, os, glob, math
import gtk, gobject, glib
import gc
import pango

# For running on tablets:
settings = gtk.settings_get_default()
settings.set_property("gtk-touchscreen-mode", True)

import xml.dom.minidom
import zipfile
import simplejson

import types, urllib, re
import collections

import time

# If we download files, we'll try to use the magic library to make
# sure we got the right file type. But no need to import it
# if we're not downloading anything.
magic_parser = None

#import pdb

#import traceback
#import cProfile

#########################################################
#
# Global Variables that you can override in your .pytopo
# (which may live in $HOME or in $home/.config/pytopo):
#

# Map collections you have, with format information.
# You must define at least one collection in .pytopo.
# It should be a list of instances of MapCollection subtypes.
# Example:
#Collections = [
#    Topo1MapCollection( "mojave", "/home/name/Maps/emj_data", 7.5, 269, 328 ),
#    GenericMapCollection( "pa-geo", "/home/name/Maps/pa-geo-300",
#                          "pa-geo-300-", ".jpg",
#                          -122.497, 37.498, 300, 400, 10746, 13124,
#                          2, True, False )
#]
# The currently supported types are:
#
# Topo1MapCollection: data from local-area Topo! packages,
#   the kind that have 7.5 minute and 15 minute varieties included.
#    (self, _name, _location, _series, tile_w, tile_h):
#
# Topo2MapCollection: data from local-area Topo! packages that
#   have only the 7.5-minute series and use jpg instead of gif.
#    (collection_name, directory_path, file_prefix, tile_w, tile_h):
#
# GenericMapCollection: a more general reader, for maps you split up
#   yourself or the Topo! national park maps.
#   ( collection_name, directory_path, filename_prefix, filename_suffix,
#     left_longitude, top_latitude, x_scale, y_scale,
#     num_digits, use_dash, latitude_first )
#    Filenames might look like: pa-map-03-17.png
#    where prefix and suffix are pa-map- and .png,
#    left_longitude and top_latitude specify the top left corner of
#    the (0, 0) image in degrees.decimal_minutes,
#    x_scale and y_scale are in pixels per degree,
#    num_digits is the number of digits used to specify grid points,
#    usedash specifies whether to put a dash between grid numbers,
#    and latitude_first indicates that latitude changes more rapidly
#    than longitude (i.e. in pa-map-03-17.png, it's the third map over
#    and the 17th map down).
# GenericMapCollection is subject to change (to add new parameters) as
# different types of map are added and the rules need to be generalized.
#Collections = []

# Named sites you might want to use as starting points.
# Format: [ sitename, longitude, latitude, collection_name ]
# Coordinates are in degrees.decimal_minutes.
# Example:
# KnownSites = [
#     # San Francisco Bay Area
#     [ "saratogagap", 122.0725, 37.155, "sfr" ],
#     [ "lexington", 121.594, 37.12, "sfr" ],
#     # Death Valley
#     [ "zabriskie", 116.475, 36.245, "deathvalley" ],
#     # From the Big Sur map:
#     [ "pinnacles", 121.0865, 36.3247, "bigsur" ],
#     ]
#KnownSites = []

#
# End of variables likely to need customization.
#
#########################################################

#########################################################
#
# Types of map collections we understand.
# If you split your own map into maplets, you may
# want to define your own subclass to handle it:
# see GenericMapCollection for an example.
#
# You can put your own subclasses in ~/.pytopo,
# but please consider contributing them so I can
# integrate them into future PyTopo releases!
#

Debug = False

class MapCollection (object):

    """A MapCollection is a set of maplet tiles on disk,
combined with knowledge about the geographic coordinates
and scale of those tiles so they can be drawn in a map window.

Child classes implementing MapCollection must define functions
__init__, get_maplet, draw_map, and get_top_left.
Get_top_left() is only for debugging, when you're trying to figure out
map coordinates and need a starting place. Should probably remove it.
"""

    def __init__(self, _name, _location):
        self.name = _name
        self.location = _location

        # Set some defaults so that we can test pytopo with a null collection:
        self.img_width = 100
        self.img_height = 100
        self.xscale = 100.
        self.yscale = 100.

    def get_maplet(self, longitude, latitude):
        """Returns pixbuf, x_offset, y_offset:
         - the pixbuf for the maplet image (or null)
         - the offset in pixels into the image for the given coordinates,
           from top left.
        """
        return None, 0, 0

    def draw_map(self, center_lon, center_lat, drawwin):
        """Draw a map in a window, centered around the specified coordinates.
        drawwin is a DrawWin object.
        """
        return

    def draw_attribution(self, drawwin):
        """Draw attribution/copyright for the map tiles used in this collection.
        """
        return

    def get_top_left(self):
        """A way to display some part of a map collection even if we're fuzzy
        on the coordinates -- get the coordinate of the first maplet
        and return as longitude, latitude."""
        return 0, 0

    def zoom(self, amount, latitude=45):
        """Zoom by the given number of steps (positive to zoom in,
        negative to zoom out). Pass amount=0 to recalculate/redraw.
        Some map collections need to know latitude to determine scale.
        """
        return

    def zoom_to(self, newzoom, latitude=45):
        """Zoom to a specific zoom level and recalculate scales.
        Some map collections need to know latitude to determine scale.
        """
        return

    def exists(self):
        """Does the collection have its map files in place?"""
        self.location = os.path.expanduser(self.location)
        return os.access(self.location, os.X_OK)

    # Spherical Mercator code,
    # from http://wiki.openstreetmap.org/wiki/Mercator#Python
    def y2lat(self, a):
        return 180.0/math.pi*(2.0*math.atan(math.exp(a*math.pi/180.0))
                              -math.pi/2.0)
    def lat2y(self, a):
        return 180.0/math.pi*math.log(math.tan(math.pi/4.0
                                               +a*(math.pi/180.0)/2.0))

    def zoom_to_bounds(self, minlon, minlat, maxlon, maxlat):
        # http://gis.stackexchange.com/questions/19632/how-to-calculate-the-optimal-zoom-level-to-display-two-or-more-points-on-a-map
        # Find spherical Mercator distances:
        xdist = maxlon - minlon
        ydist = self.lat2y(maxlat) - self.lat2y(minlat)
        # The equator is about 40m meters long projected and tiles are
        # 256 pixels wide, so the pixel length of that map at a given
        # zoom level is about 256 * distance/40000000 * 2^zoom.
        # But it needs another factor of 100000, determined empirically.
        mult = 256. * 100000. / 40000000.
        z = 0

        # Handle the case of a single point
        if xdist == 0 or ydist == 0:
            print "Single point! Zooming to maxzoom", self.maxzoom
            self.zoom_to(self.maxzoom)
            return

        while z <= self.maxzoom:
            powz = pow(2, z)
            w = xdist * mult * powz
            h = ydist * mult * powz
            # print z, ": Size", w, "x", h
            if w > 800 or h > 600:
                self.zoom_to(z-1)
                return
            z += 1
        print "Couldn't fit bounding box; using maximum zoom"
        self.zoom_to(self.maxzoom)

class TiledMapCollection(MapCollection):

    """Code common to map collections that have raster tiles of a fixed size.
TiledMapCollection classes must implement
  (pixbuf, x_off, y_off, pathname) = get_maplet(curlon, curlat)
  (pixbuf, newpath) = get_next_maplet(oldpath, dX, dY)
"""

    def __init__(self, _name, _location, _tile_w, _tile_h):
        MapCollection.__init__(self, _name, _location)
        self.img_width = _tile_w
        self.img_height = _tile_h

        # For collections that support downloading new tiles,
        # keep a list of tiles that still need downloading:
        self.download_tiles = DownloadTileQueue()
        self.download_func = None
        self.download_failures = 0

    def set_reload_tiles(self, p):
        if p:
            if 'download_url' in dir(self) and self.download_url:
                print "Will re-download all map tiles"
                self.reload_tiles = p
            else:
                print "Error: can't reload tiles without a download URL"
                self.reload_tiles = False
        else:
            self.reload_tiles = False

    def draw_map(self, center_lon, center_lat, mapwin):
        """Draw maplets at the specified coordinates, to fill the mapwin."""

        # Get the current window size:
        win_width, win_height = mapwin.get_size()
        if (Debug):
            print "Window is", win_width, "x", win_height

        # Now that we have a latitude, call zoom so we can finally
        # set the x and y scales accurately.
        self.zoom(0, center_lat)

        # Find the coordinate boundaries for the set of maps to draw.
        # This may (indeed, usually will) include maps partly off the screen,
        # so the coordinates will span a greater area than the visible window.
        if (Debug):
            print "Calculating boundaries: min =", \
                   MapUtils.dec_deg2deg_min_str(center_lon), \
                   center_lon, "+/-", win_width, \
                   "/", self.xscale, "/ 2"
        min_lon = center_lon - win_width / self.xscale / 2
        max_lon = center_lon + win_width / self.xscale / 2
        min_lat = center_lat - win_height / self.yscale / 2
        max_lat = center_lat + win_height / self.yscale / 2

        if (Debug):
            print "Map from", min_lon, MapUtils.dec_deg2deg_min_str(min_lon), \
                   MapUtils.dec_deg2deg_min_str(min_lat), \
                   "to", MapUtils.dec_deg2deg_min_str(max_lon), \
                   MapUtils.dec_deg2deg_min_str(max_lat)

        # Start from the upper left: min_lon, max_lat

        #pdb.set_trace()
        curlat = max_lat
        cur_y = 0
        y_maplet_name = None
        initial_x_off = None
        while cur_y < win_height:
            curlon = min_lon
            cur_x = 0
            x_maplet_name = None
            while cur_x < win_width:

                # Reset the expected image size:
                w = self.img_width
                h = self.img_height

                # Is it the first maplet in this row?
                if x_maplet_name == None:

                    # Is it the first maplet in the map --
                    # usually the one in the upper left corner?
                    # Then we need to specify coordinates.
                    if y_maplet_name == None:
                        pixbuf, x_off, y_off, x_maplet_name = \
                            self.get_maplet(curlon, curlat)

                        # Save the x offset: we'll need it for the
                        # beginning of each subsequent row.
                        initial_x_off = x_off

                    # Not upper left corner --
                    # must be the beginning of a new row.
                    # Get the maplet below the beginning of the last row.
                    else:
                        pixbuf, x_maplet_name = \
                            self.get_next_maplet(y_maplet_name, 0, 1)
                        x_off = initial_x_off
                        y_off = 0

                    # Either way, whether or not we got a pixbuf,
                    # if we're at the beginning of a row, save the
                    # beginning-of-row maplet name and the offset:
                    if cur_x == 0:
                        y_maplet_name = x_maplet_name

                # Continuing an existing row.
                # Get the maplet to the right of the last one.
                else:
                    pixbuf, x_maplet_name = self.get_next_maplet(x_maplet_name,
                                                                 1, 0)
                    x_off = 0

                if Debug:
                    print "    ", x_maplet_name

                x = cur_x
                y = cur_y

                w, h = self.draw_tile_at_position(pixbuf, mapwin,
                                                  x, y, x_off, y_off)
                # You may ask, why not just do this subtraction before
                # draw_pixbuf so we don't have to subtract w and h twice?
                # Alas, we may not have the real w and h until we've done
                # pixbuf.get_width(), so we'd be subtracting the wrong thing.
                # XXX Not really true any more, since we're assuming fixed
                # XXX tile size. Revisit this!
                cur_x += w
                curlon += float(w) / self.xscale

            if (Debug):
                print " "
                print "New row: adding y =", h,
                print "Subtracting lat", float(h) / self.yscale

            cur_y += h
            curlat -= float(h) / self.yscale
            #curlat -= float(self.img_height) / self.yscale

        # Free all pixbuf data. Just letting pixbuf go out of scope
        # isn't enough; it's necessary to force garbage collection
        # otherwise Python will let the process grow until it
        # fills all of memory.
        # http://www.daa.com.au/pipermail/pygtk/2003-December/006499.html
        # (At this indentation level, we free after drawing the whole map.)
        gc.collect()

        # If we queued any downloads and aren't currently downloading,
        # schedule a function to take care of that:
        if len(self.download_tiles) > 0 and self.download_func == None:
            gobject.timeout_add(300, self.download_more)

    def get_next_maplet_name(self, fullpathname, dX, dY):
        """Starting from a maplet name, get the one a set distance away."""
        return

    def get_next_maplet(self, fullpathname, dX, dY):
        """Given a maplet's pathname, get the next or previous one.
        May not work for jumps more than 1 in any direction.
        Returns pixbuf, newpath (either may be None).
        """
        return

    def draw_tile_at_position(self, pixbuf, mapwin, x, y, x_off, y_off):
        """Draw a single tile, perhaps after downloading it,
           at a specified location.
       ."""
        if pixbuf != None:
            w = pixbuf.get_width() - x_off
            h = pixbuf.get_height() - y_off
            if (Debug):
                print "img size:", pixbuf.get_width(), \
                      pixbuf.get_height()

            # If the image won't completely fill the grid space,
            # fill the whole rectangle first with black.
            # Note: this may not guard against images with
            # transparent areas. Don't do that.
            if (pixbuf.get_width() < self.img_width or
                pixbuf.get_height() < self.img_height):
                mapwin.set_bg_color()
                mapwin.draw_rectangle(1, x, y,
                                      self.img_width, self.img_height)
                if (Debug):
                    print "Filling in background:", x, y,
                    print self.img_width, self.img_height

            # if (Debug):
            #     print "Drawing maplet for",
            #     print MapUtils.dec_deg2deg_min_str(curlon),
            #     print MapUtils.dec_deg2deg_min_str(curlat),
            #     print "at", x, y, "offset", x_off, y_off,
            #     print "size", w, h

            mapwin.draw_pixbuf(pixbuf, x_off, y_off, x, y, w, h)

            # Make sure the pixbuf goes out of scope properly:
            pixbuf = 0
        else:
            # if (Debug):
            #     print "No maplet for", curlon, curlat,
            #     print "at", x, y, "offset", x_off, y_off
            mapwin.set_bg_color()
            w = self.img_width - x_off
            h = self.img_height - y_off
            mapwin.draw_rectangle(1, x, y, w, h)

        # Useful when testing:
        if (Debug):
            mapwin.set_color(mapwin.grid_color)
            mapwin.draw_rectangle(0, x, y, w, h)
            mapwin.draw_line(x, y, x+w, y+h)
            mapwin.set_bg_color()
        return w, h

    def draw_single_tile(self, path, mapwin):
        '''After a new tile is downloaded, fetch its pixbuf and draw it
           in the right place for our currently displayed map.
        '''
        # Calculate x, y, x_offset, y_offset from the tile name.
        # Make sure it's even still visible.
        # Tile name is /path/to/zoom/x/y.ext
        head, tiley = os.path.split(path)
        tiley = os.path.splitext(tiley)[0]
        head, tilex = os.path.split(head)
        head, tilezoom = os.path.split(head)
        try:
            tiley = int(tiley)
            tilex = int(tilex)
        except ValueError:
            print "Bad tile filename", path
            return
        # Now we need to turn tilex and tiley into x, y, x_off, y_off
        # for the MapWindow's current position.
        lat_deg, lon_deg = self.num2deg(tilex, tiley)

        # Where on the map window should this lat and lon appear?
        min_lon = mapwin.center_lon - mapwin.win_width / self.xscale / 2
        max_lat = mapwin.center_lat + mapwin.win_height / self.yscale / 2
        mapx = int((lon_deg - min_lon) * self.xscale)
        mapy = int((max_lat - lat_deg) * self.yscale)

        if mapx < 0:
            x_off = -mapx
            mapx = 0
        else:
            x_off = 0
        if mapy < 0:
            y_off = -mapy
            mapy = 0
        else:
            y_off = 0

        try:
            pixbuf = gtk.gdk.pixbuf_new_from_file(path)
            self.draw_tile_at_position(pixbuf, mapwin, mapx, mapy, x_off, y_off)
        except glib.GError, e:
            print "Couldn't draw tile:", e,
            if not Debug:
                print "... deleting"
            else:
                print ""
            print ""
            if os.path.exists(path) and not Debug:
                os.unlink(path)
            self.download_failures += 1
            # Usually this means OSM gave us a text file containing
            # a string like "Tile Not Available"
        except Exception, e:
            print "Error drawing tile:", e
            self.download_failures += 1

        # Redraw any trackpoints, since they might have been overwritten.
        # XXX should schedule this after a delay, so we're not constantly
        # redrawing large sets of trackpoints each time a new tile comes in.
        mapwin.draw_trackpoints()

    def download_finished(self, path):
        """Callback when a tile finishes downloading.
           The path argument is either the local file path just downloaded,
           or an exception, e.g. IOError.
        """

        # If we got too many failures -- usually IOError,
        # perhaps we're offline -- path will be None here.
        # In that case, just give up on downloading.
        if path == None:
            self.download_failures += 1
            if self.download_failures > 10:
                print "\nDownload failed; giving up"
                self.download_func = None
                # Clear self.download_tiles, so that if the net returns
                # we'll start on new stuff, not old stuff.
                # Not clear if this is the right thing to do or not.
                self.download_tiles = DownloadTileQueue()
                self.download_failures = 0
                return

        # Otherwise, we got a path for a successful tile download.
        # Reset the failure counter:
        #self.download_failures += 1

        self.download_tiles.pop()   # Throw away url, path popped
        self.draw_single_tile(path, self.mapwin)

        # It's okay to start a new download now:
        self.download_func = None

        # Anything more to download?
        if len(self.download_tiles) > 0:
            self.download_more()

    def download_more(self):
        """Idle/timeout proc to download any pending tiles.
           Should always return False so it won't get rescheduled.
           Eventually this should download in a separate thread.
        """

        # If we already have a download going, don't start another one
        # (eventually we'll want to run several in parallel).
        if self.download_func != None:
            if Debug:
                print "There's already a download going; not downloading more"
            return False

        # If there are no more tiles to download, we're done:
        if len(self.download_tiles) == 0:
            self.download_func = None
            return False

        url, path = self.download_tiles.peek()
        # Don't actually pop() it until it has downloaded.
        #urllib.urlretrieve(url, path)
        self.download_func = start_job(download_job(url, path,
                                                    self.download_finished))
        if Debug:
            print "Started download %s to %s" % (url, path)

        return False

class OSMMapCollection(TiledMapCollection):

    """
    A collection of tiles downloaded from the OpenStreetMap project
    or one of its renderers, using the OSM naming scheme.
    See also http://tfischernet.wordpress.com/2009/05/04/drawing-gps-traces-on-map-tiles-from-openstreetmap/

    @ivar: zoomlevel   The current zoom level.
    @ivar: location    Where on disk the map tiles reside.
    @ivar: download_url Where to download new tiles.
    """

    def __init__(self, _name, _location, _ext,
                 _img_width, _img_height, _init_zoom,
                 _download_url=None, maxzoom=19,
                 reload_if_older=None, attribution=None):
        """arguments:
        name         -- user-visible name of the collection
        location     -- directory on disk where the maps reside
        ext          -- filename extension including the dot, e.g. .jpg
        img_width    -- width of each maplet
        img_height   -- height of each maplet
        init_zoom    -- default initial zoom level
        download_url -- try to download missing maplets from here
        reload_if_older: if set, reload tiles older than this (in days)
        """
        TiledMapCollection.__init__(self, _name, _location,
                                    _img_width, _img_height)
        self.ext = _ext
        self.img_width = _img_width
        self.img_height = _img_height
        self.zoomlevel = _init_zoom
        self.powzoom = 2.0 ** self.zoomlevel   # to avoid re-re-calculating
        self.download_url = _download_url
        self.maxzoom = maxzoom

        # We need to keep a pointer to the map window for redrawing
        # when downloaded tiles come in.
        self.mapwin = None

        # If reload_tiles is set, it should be set to a Unix datestamp,
        # e.g. from when the program was started.
        # Any file older than that will be re-downloaded.
        # By default, never reload tiles.
        if reload_if_older:
            self.reload_tiles = time.time() - reload_if_older * 60*60*24
        else:
            self.reload_tiles = False

        if attribution:
            self.attribution = attribution
        else:
            self.attribution = "Map tiles copyright Openstreetmap.org"

        self.location = os.path.expanduser(self.location)

        # Handle ~ format for location

        # If we're download-capable, we'd better have a directory
        # to download to, so make it if it's not there already:
        if self.download_url and not os.access(self.location, os.W_OK):
            # XXX wrap in a try, show user-visible error dialog!
            os.makedirs(self.location)

        # Call zoom so we set all scales appropriately:
        self.zoom(0)

    def draw_map(self, center_lon, center_lat, mapwin):
        """Draw maplets at the specified coordinates, to fill the mapwin."""
        self.mapwin = mapwin
        # call parent
        return super(OSMMapCollection, self).draw_map(center_lon, center_lat,
                                                      mapwin)

    def draw_attribution(self, mapwin):
        mapwin.draw_string_scale(-10, 1, self.attribution,
                                 whichfont="attribution")
        return

    # Utilities for mapping tiles to/from degrees.
    # From http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
    def deg2num(self, lat_deg, lon_deg, zoom=None):
        """Map coordinates to tile numbers and offsets.
           @return:  (xtile, ytile, x_off, y_off)
        """
        if zoom:
            powzoom = 2.0 ** zoom
        else:
            powzoom = self.powzoom
        lat_rad = math.radians(lat_deg)
        xtilef = (lon_deg + 180.0) / 360.0 * powzoom
        ytilef = ((1.0 - math.log(math.tan(lat_rad) +
                                  (1 / math.cos(lat_rad))) / math.pi)
                  / 2.0 * powzoom)
        xtile = int(xtilef)
        ytile = int(ytilef)

        tilesize = 256
        x_off = int((xtilef - xtile) * tilesize)
        y_off = int((ytilef - ytile) * tilesize)

        return(xtile, ytile, x_off, y_off)

    def num2deg(self, xtile, ytile):
        """Map OSM tile file numbers to coordinates.
           @return:  (lat_deg, lon_deg)
        """
        lon_deg = xtile / self.powzoom * 360.0 - 180.0
        lat_rad = math.atan(math.sinh(math.pi * (1 - 2 * ytile / self.powzoom)))
        lat_deg = math.degrees(lat_rad)
        return (lat_deg, lon_deg)

    def zoom_to(self, newzoom, latitude=45):
        """Zoom to a specific zoom level, updating scales accordingly.
        Pass latitude for map collections (e.g. OSM) that cover
        large areas so scale will tend to vary with latitude.
        """

        if self.zoomlevel != newzoom:
            if newzoom > self.maxzoom:
                print "Can't zoom past level", self.maxzoom, "in", \
                    self.name, "map collections"
                return
            self.zoomlevel = newzoom
            self.powzoom = 2.0 ** self.zoomlevel

        # Get scale, in pixels / degree.
        # (2 ** zoomlevel) tiles covers the whole world.
        self.xscale = self.powzoom * 180./256.

        # But because of the Mercator projection,
        # yscale has to be adjusted for latitude.
        (xtile, ytile, x_off, y_off) = self.deg2num(latitude, 180)
        (lat1, lon1) = self.num2deg(xtile, ytile)
        (lat2, lon2) = self.num2deg(xtile+1, ytile-1)
        self.xscale = 256. / (lon2 - lon1)
        self.yscale = 256. / (lat2 - lat1)
        if Debug:
            print "Zoom to %d: Calculated scales: %f, %f" \
                % (self.zoomlevel, self.xscale, self.yscale)
        return

    def zoom(self, amount, latitude=45):
        """Zoom in or out by the specified amount,
        updating the scales appropriately.
        Call zoom(0) to update x/y scales without changing zoom level.
        Pass latitude for map collections (e.g. OSM) that cover
        large areas so scale will tend to vary with latitude.
        """
        self.zoom_to(self.zoomlevel + amount, latitude)

    def get_maplet(self, longitude, latitude):
        """Fetch or queue download for the maplet containing the
        specified coordinates.
        Input coordinates are in decimal degrees.
        Returns pixbuf, x_offset, y_offset, filename
        where offsets are pixels from top left of the specified coords
        and pixbuf or (less often) filename may be None.
        """

        (xtile, ytile, x_off, y_off) = self.deg2num(latitude, longitude)

        filename = os.path.join(self.location, str(self.zoomlevel),
                                str(xtile), str(ytile)) + self.ext
        pixbuf = self.fetch_or_download_maplet(filename)
        return pixbuf, x_off, y_off, filename

    # maplet size is 256. Files per dir:
    # at zoomlevel 12, 28
    # at zoomlevel 13, 53
    # at zoomlevel 14, 107
    def get_next_maplet_name(self, fullpathname, dX, dY):
        """Starting from a maplet name, get the one a set distance away."""
        fulldir, filename = os.path.split(fullpathname)
        ystr, ext = os.path.splitext(filename)
        zoomdir, xstr = os.path.split(fulldir)
        xstr = str(int(xstr) + dX)
        ystr = str(int(ystr) + dY)

        return os.path.join(zoomdir, xstr, ystr + ext)

    def get_next_maplet(self, fullpathname, dX, dY):
        """Given a maplet's pathname, get the next or previous one.
        May not work for jumps more than 1 in any direction.
        Returns pixbuf, newpath (either may be None).
        """
        newpath = self.get_next_maplet_name(fullpathname, dX, dY)
        if newpath == None:
            return None, newpath

        pixbuf = self.fetch_or_download_maplet(newpath)
        return pixbuf, newpath

    def url_from_path(self, path, zoomlevel=None):
        """URL we need to get the given tile file.
           URLs can be specified like
           "http://a.tile.openstreetmap.org", and we will append /zoom/x/y.ext
           or they can be specified like
           "https://tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey=X"
           and we will substitute {z}, {x} and {y}.
        """
        if not zoomlevel:
            zoomlevel = self.zoomlevel

        xdir, filename = os.path.split(path)
        xdir = os.path.basename(xdir)
        y, ext = os.path.splitext(filename)

        url = self.download_url.format(z=zoomlevel, x=xdir, y=y)

        if url == self.download_url:
            # Didn't replace anything, so do it old-style
            return url + '/' + str(zoomlevel) + '/' \
                + xdir + '/' + filename
        else:
            return url

    def fetch_or_download_maplet(self, path):
        """Return a pixbuf if the file is on disk, else download"""
        # Does the tile already exist on local disk?
        # Even if it does, do we need to re-download it?
        # XXX This calls os.access then os.stat. Does that mean
        # we're statting the file twice? Might be a performance issue.
        try:
            on_disk = os.access(path, os.R_OK)
            needs_download = (not on_disk) or \
                             (self.reload_tiles and
                              os.stat(path).st_mtime < self.reload_tiles)
        except OSError:
            on_disk = False
            needs_download = True

        if needs_download:
            if self.download_url:
                # path is a full path on the local filesystem, OS independent.
                # We need to turn it into a url (Unix path) with slashes.
                thedir = os.path.dirname(path)
                if not os.access(thedir, os.W_OK):
                    os.makedirs(thedir)

                self.download_tiles.push(self.url_from_path(path), path)

            else:
                if Debug:
                    print "Downloads not enabled; skipping", path

        # We've queued any needed downloads.
        # Now return the current pixbuf, if any.
        if not on_disk:
            return None

        try:
            pixbuf = gtk.gdk.pixbuf_new_from_file(path)
        except gobject.GError:
            pixbuf = None
            # return None

        # In case something went wrong, don't keep a bad file around:
        if not pixbuf or pixbuf.get_width() <= 0 or pixbuf.get_height() <= 0:
            print "Couldn't open pixbuf from", path
            os.rename(path, path + ".bad")

        return pixbuf

    def coords_to_filename(self, longitude, latitude):
        """Given coordinates in decimal degrees, map to the closest filename"""
        return None

    def get_top_left(self):
        """Get the coordinates of the top left corner of the map."""
        return None, None

class GenericMapCollection(TiledMapCollection):

    """
    A GenericMapCollection is tiled, like the Topo collections,
    but uses a less specific naming scheme:
    prefix-nn-mm.ext, with or without the dashes.
    """

    def __init__(self, _name, _location, _prefix, _ext,
                 _left_long, _top_lat,
                 _img_width, _img_height, _xscale, _yscale,
                 _numdigits, _usedash, _latfirst):
        """arguments:
        name       -- user-visible name of the collection
        location   -- directory on disk where the maps reside
        prefix     -- initial part of each maplet filename
        ext        -- filename extension including the dot, e.g. .jpg
        left_long  -- longitude of the left edge
        top_lat    -- latitude of the top edge
        img_width  -- width of each maplet in pixels
        img_height -- height of each maplet in pixels
        xscale     -- pixels per degree longitude
        yscale     -- pixels per degree latitude
        numdigits  -- number of digits in x and y file specifiers
        usedash    -- Boolean, use a dash between x and y in filenames?
        latfirst   -- Boolean, is latitude the first of the two numbers?

        """
        TiledMapCollection.__init__(self, _name, _location,
                                    _img_width, _img_height, )
        self.prefix = _prefix
        self.numdigits = _numdigits
        self.usedash = _usedash
        self.ext = _ext
        self.latfirst = _latfirst
        self.img_width = _img_width
        self.img_height = _img_height
        self.left_longitude = _left_long    # Left of 00-00 image
        self.top_latitude = _top_lat        # Top of 00-00 image
        self.xscale = float(_xscale)        # Pixels per degree
        self.yscale = float(_yscale)        # Pixels per degree

    def get_maplet(self, longitude, latitude):
        """Get the maplet containing the specified coordinates.
        Returns pixbuf, x_offset, y_offset, filename
        where offsets are pixels from top left of the specified coords
        and pixbuf or (less often) filename may be None.
        """
        filename = self.coords_to_filename(longitude, latitude)
        if (Debug):
            print "Generic get_maplet", longitude, latitude, "->", filename
        if filename == None or not os.access(filename, os.R_OK):
            #print "Can't open", filename, "for", longitude, latitude
            return None, 0, 0, filename
        #print "Opened", filename, "for", longitude, latitude
        pixbuf = gtk.gdk.pixbuf_new_from_file(filename)

        # Offsets aren't implemented yet:
        x_off = 0
        y_off = 0

        return pixbuf, x_off, y_off, filename

    def get_next_maplet(self, fullpathname, dX, dY):
        """Given a maplet's pathname, get the next or previous one.
        Does not currently work for jumps more than 1 in any direction.
        Returns pixbuf, newpath (either may be None).
        """
        pathname, filename = os.path.split(fullpathname)
        if (Debug):
            print "Generic get_next_maplet", filename, dX, dY
        name, ext = os.path.splitext(filename)
        #traceback.print_stack()
        mapb = int(name[-self.numdigits:])
        if self.usedash:
            mapa = int(name[-self.numdigits*2 - 1 : -self.numdigits-1])
        else:
            mapa = int(name[-self.numdigits*2 : -self.numdigits])
        if self.latfirst:
            newa = MapUtils.ohstring(mapa + dX, self.numdigits)
            newb = MapUtils.ohstring(mapb + dY, self.numdigits)
        else:
            newa = MapUtils.ohstring(mapa + dY, self.numdigits)
            newb = MapUtils.ohstring(mapb + dX, self.numdigits)
        if self.usedash:
            newname = self.prefix + newa + "-" + newb
        else:
            newname = self.prefix + newa + newb
        newpath = os.path.join(self.location, newname + ext)
        if filename == None or not os.access(filename, os.R_OK):
            return None, newpath
        pixbuf = gtk.gdk.pixbuf_new_from_file(newpath)
        return pixbuf, newpath

    def coords_to_filename(self, longitude, latitude):
        """Given coordinates in decimal degrees, map to the closest filename"""
        if self.left_longitude > longitude or self.top_latitude < latitude:
            return None
        x_grid = MapUtils.int_trunc((longitude - self.left_longitude) *
                                   self.xscale / self.img_width)
        y_grid = MapUtils.int_trunc((self.top_latitude - latitude) *
                                   self.yscale / self.img_height)
        if not self.latfirst:
            temp = x_grid
            x_grid = y_grid
            y_grid = temp
        retstr = os.path.join(self.location,
                              self.prefix + MapUtils.ohstring(x_grid,
                                                              self.numdigits))
        if self.usedash:
            retstr = retstr + "-"
        retstr = retstr + MapUtils.ohstring(y_grid, self.numdigits) + self.ext
        return retstr

    def get_top_left(self):
        """Get the coordinates of the top left corner of the map."""
        return self.left_longitude, self.top_latitude

class TopoMapCollection(TiledMapCollection):

    """TiledMapCollections using the Topo! map datasets.
    Filenames are named according to a fairly strict convention.
    Some variants can toggle between more than one scale (series).
    """

    def __init__(self, _name, _location, _series, _tile_w, _tile_h,
                 _ser7prefix="012t", _ser15prefix="024t", _img_ext=".gif"):
        """arguments:
        name        -- user-visible name of the collection
        location    -- directory on disk where the maps reside
        series      -- initial series to use, 7.5 or 15 minutes of arc.
        tile_w      -- width of each maplet in pixels
        tile_h      -- height of each maplet in pixels
        img_ext     -- filename extension including the dot, e.g. .jpg
        ser7prefix  -- prefix for tile files implementing the 7.5-min series
        ser15prefix -- prefix for tile files implementing the 15-min series
        """

        TiledMapCollection.__init__(self, _name, _location, _tile_w, _tile_h)
        self.set_series(_series)
        self.ser7prefix = _ser7prefix
        self.ser15prefix = _ser15prefix
        self.img_ext = _img_ext

        # _correction because Topo1 maps aren't in WGS 84.
        # Right now these numbers are EMPIRICAL and inaccurate.
        # Need to do them right!
        # http://www.ngs.noaa.gov/cgi-bin/nadcon.prl says the correction
        # in the Mojave area from NAD27 to NAD84 (nobody converts to
        # WGS84, alas) should be -0.05463', 2.99014' (-1.684m, 75.554m)
        self.lon_correction = 0 # 0.032778 / 1000
        self.lat_correction = 0 # -1.794084 / 1000

    def set_series(self, _series):
        """Set the series to either 7.5 or 15 minutes."""

        #traceback.print_stack()
        self.series = _series
        self.xscale = self.img_width * 600.0 / self.series
        self.yscale = self.img_height * 600.0 / self.series
        if (Debug):
            print "set series to", self.series
        # 600 is minutes/degree * maplets/minute

        # The fraction of a degree that each maplet spans:
        self.frac = float(self.img_width) / self.xscale
        if (Debug):
            if self.frac != float(self.img_height) / self.yscale:
                print "x and y fractions not equal!",
                print self.frac, float(self.img_height) / self.yscale

    def get_maplet(self, longitude, latitude):
        """Get the maplet containing the specified coordinates.
        Returns pixbuf, x_offset, y_offset, filename
        where offsets are pixels from top left of the specified coords
        and pixbuf or (less often) filename may be None.
        """

        filename = self.coords_to_filename(longitude - self.lon_correction,
                                         latitude - self.lat_correction)
        if (Debug):
            print "T1MC get_maplet(", MapUtils.dec_deg2deg_min_str(longitude),
            print  ",", MapUtils.dec_deg2deg_min_str(latitude), "):", filename

        # Calculate offsets.
        # Maplets are self.series minutes wide and tall,
        # so any offset from that is an offset into the maplet:
        # the number of pixels in X and Y that have to be added
        # to get from the maplet's upper left corner to the
        # indicated coordinates.
        # But then we have to correct to get to WGS84 coordinates.
        # XXX the WGS84 part doesn't work right yet.

        # longitude increases rightward:
        x_off = int((longitude - MapUtils.truncate2frac(longitude, self.frac)
                     - self.lon_correction) * self.xscale)
        if (Debug):
            print "truncated", MapUtils.dec_deg2deg_min_str(longitude), "to",
            print MapUtils.dec_deg2deg_min_str(MapUtils.truncate2frac(longitude,
                                                                     self.frac))

        # Latitude decreases downward:
        y_off = int((MapUtils.truncate2frac(latitude, self.frac) +
                     self.frac - latitude - self.lat_correction) * self.yscale)

        if (Debug):
            print "truncated", MapUtils.dec_deg2deg_min_str(latitude), "to",
            print MapUtils.dec_deg2deg_min_str(MapUtils.truncate2frac(latitude,
                                                                     self.frac))
            print "y_off is", y_off

        if not os.access(filename, os.R_OK):
            return None, x_off, y_off, filename
        pixbuf = gtk.gdk.pixbuf_new_from_file(filename)

        return pixbuf, x_off, y_off, filename

    def get_next_maplet(self, fullpathname, dX, dY):
        """Given a maplet's pathname, get the next or previous one.
        Does not currently work for jumps more than 1 in any direction.
        Returns pixbuf, newpath (either may be None).
        """

        if (Debug):
            print "get_next_maplet:", fullpathname, dX, dY
        pathname, filename = os.path.split(fullpathname)
        collecdir, mapdir = os.path.split(pathname)
        maplat = int(mapdir[1:3])
        maplon = int(mapdir[3:6])
        name, ext = os.path.splitext(filename)
        xdir = int(mapdir[-1])
        ydir = ord(mapdir[-2]) - ord('a')     # convert from letter a-h
        if self.series == 7.5:
            serstr = self.ser7prefix
            grid = 10
        else:
            serstr = self.ser15prefix
            grid = 5

        x = int(name[-4:-2]) + dX
        y = int(name[-2:]) + dY

        if x < 1:
            x = grid
            xdir = xdir + 1
            if xdir > 8:
                xdir = 1
                if Debug:
                    print mapdir, name, ": wrapping mapdir coordinates -x",
                    print maplon
                maplon = str(int(maplon) + 1)
        if x > grid:
            x = 1
            xdir = xdir - 1
            if xdir < 1:
                xdir = 8
                if Debug:
                    print mapdir, name, ": wrapping mapdir coordinates +x",
                    print maplon
                maplon = str(int(maplon) - 1)

        if y > grid:
            y = 1
            ydir = ydir - 1
            if ydir < 0:
                ydir = 7
                if Debug:
                    print mapdir, name, ": wrapping mapdir coordinates +y",
                    print maplat
                maplat = str(int(maplat) - 1)

        if y < 1:
            y = grid
            ydir = ydir + 1
            if ydir > 7:
                ydir = 0
                if Debug:
                    print mapdir, name, ": wrapping mapdir coordinates -y",
                    print maplat
                maplat = str(int(maplat) + 1)

        # We're ready to piece the filename back together!
        newpath = os.path.join(collecdir,
                               "q" + MapUtils.ohstring(maplat, 2) \
                                   + MapUtils.ohstring(maplon, 3) \
                                   + chr(ydir + ord('a')) + str(xdir),
                               serstr + MapUtils.ohstring(x, 2) \
                                   + MapUtils.ohstring(y, 2) + ext)
        if not os.access(newpath, os.R_OK):
            if Debug:
                print "get_next_maplet(", fullpathname, dX, dY, ")"
                print "  Can't open", newpath
            return None, newpath

        pixbuf = gtk.gdk.pixbuf_new_from_file(newpath)
        return pixbuf, newpath

    #
    # Quirk: Topo1 collections are numbered with WEST longitude --
    # i.e. longitude is written as positive but it's actually negative.
    #
    # Second quirk: Topo1 collections aren't in the WGS 84 coordinate
    # system used by GPS receivers, and need to be translated.
    # http://en.wikipedia.org/wiki/Geographic_coordinate_system
    # http://en.wikipedia.org/wiki/Geodetic_system
    #
    def coords_to_filename(self, longitude, latitude):
        """Given a pair of coordinates in deg.mmss, map to the
        containing filename, e.g. q37122c2/012t0501.gif.
        """

        latDeg = MapUtils.int_trunc(latitude)
        longDeg = MapUtils.int_trunc(-longitude)
        latMin = (latitude - latDeg ) * 60.
        longMin = (-longitude - longDeg) * 60.

        # The 7.5 here is because of the 7.5 in the directory names above
        # (we're getting the offset of this image from the origin of
        # the 7.5-series map covered by the directory),
        # not the map series we're actually plotting now.
        longMinOrd = MapUtils.int_trunc(longMin / 7.5)
        latMinOrd = MapUtils.int_trunc(latMin / 7.5)

        dirname = "q" + MapUtils.ohstring(latDeg, 2) \
            + MapUtils.ohstring(longDeg, 3) \
            + chr(ord('a') + latMinOrd) + str(longMinOrd+1)

        # Find the difference between our desired coordinates
        # and the origin of the map this directory represents.
        # The 7.5 here is because of the 7.5 in the directory names above.
        latMinDiff = latMin - (latMinOrd * 7.5)
        longMinDiff = longMin - (longMinOrd * 7.5)

        latOffset = MapUtils.int_trunc(latMinDiff * 10 / self.series)
        longOffset = MapUtils.int_trunc(longMinDiff * 10 / self.series)

        # Now calculate the current filename.
        # Note that series is either 7.5 or 15
        if (self.series > 13):
            fileprefix = "024t"
            numcharts = 5
        else:
            fileprefix = "012t"
            numcharts = 10
        filename = fileprefix + MapUtils.ohstring(numcharts-longOffset, 2) + \
                   MapUtils.ohstring(numcharts-latOffset, 2) + self.img_ext

        return self.location + "/" + dirname + "/" + filename

    def dir_to_latlong(self, qdir):
        """Given a directory, figure out the corresponding coords."""
        letter = ord(qdir[6]) - ord('a')
        digit = int(qdir[7]) - 1
        thislon = -int(qdir[3:6]) + (digit * 7.5 * 1.5 / 60)
        #thislon += self.lon_correction
        thislat = int(qdir[1:3]) + (letter * 7.5 * 1.5 / 60)
        #thislat += self.lat_correction
        return thislon, thislat

    def get_top_left(self):
        """Get the coordinates of the top left corner of the map."""
        minlong = 181
        maxlat = -91
        topleftdir = None

        mapdirs = os.listdir(self.location)
        # mapdirs.sort()
        for mapdir in mapdirs:
            if mapdir[0] == 'q':
                # Now first_mapdir is some name like "qAAABBcD" ... decode it.
                thislong, thislat = self.dir_to_latlong(mapdir)
                #if thislong < minlong and thislat > maxlat:
                if thislong < minlong:
                    minlong = thislong
                    if thislat > maxlat:
                        maxlat = thislat
                        topleftdir = mapdir
        if maxlat < -90 or minlong > 180:
            return 0, 0    # shouldn't happen

        # Now we have the top left directory. Still need the top left file:
        files = os.listdir(os.path.join(self.location, topleftdir))

        return minlong, maxlat

# End of TopoMapCollection class

class Topo1MapCollection(TopoMapCollection):

    """
Topo1MapCollection: data from local-area Topo! packages,
  the kind that have 7.5 minute and 15 minute varieties included.
   (self, _name, _location, _series, tile_w, tile_h):
    """

    def __init__(self, _name, _location, _series, _tile_w, _tile_h):
        TopoMapCollection.__init__(self, _name, _location, _series,
                                   _tile_w, _tile_h,
                                   _ser7prefix="012t", _ser15prefix="024t",
                                   _img_ext=".gif")

    def zoom(self, amount, latitude=45):
        if self.series == 7.5 and amount < 0:
            self.set_series(15)
        elif self.series == 15 and amount > 0:
            self.set_series(7.5)

# A Topo2MapCollection is just a Topo1MapCollection that has only
# 7.5-series and has a different file prefix.
# On North Palisade 7.5 (q37118a5) we get 410x256 pixel images.
class Topo2MapCollection(TopoMapCollection):

    """
Topo2MapCollection: data from local-area Topo! packages that
  have only the 7.5-minute series and use jpg instead of gif.
   (collection_name, directory_path, file_prefix, tile_w, tile_h):
    """

    def __init__(self, _name, _location, _prefix, _tile_w, _tile_h):
        TopoMapCollection.__init__(self, _name, _location, 7.5,
                                   _tile_w, _tile_h,
                                   _ser7prefix=_prefix, _ser15prefix=None,
                                   _img_ext=".jpg")

class TrackPoints:

    """Parsing and handling of GPS track files.
       Supports GPX, KML, KMZ and GeoJSON.
       A TrackPoints object can include a track (points[])
       and a list of waypoints (waypoints[]).

       Each point in a track can be either a trackpoint or the beginning
       of a new track segment.

       Beginnings of segments are represented by the name of the
       segment as a string or unicode, but use is_start() to test for
       that in case of future changes.

       A trackpoint is an array where the first two elements are
       longitude and latitude, as floatings.
       Following longitude there may be an optional elevation, a float,
       or waypoint name, a string or unicode.
       Finally, a dictionary may be present, containing additional
       elements like time (timestamp).

    """

    def __init__(self):
        self.points = []
        self.waypoints = []
        self.minlon = 361
        self.maxlon = -361
        self.minlat = 91
        self.maxlat = -91

    def get_bounds(self):
        return self.minlon, self.minlat, self.maxlon, self.maxlat

    def is_start(self, point):
        '''Is this the start of a new track segment?
           If so, it's a string (or unicode), the name of the track section.
        '''
        return (isinstance(point, str) or isinstance(point, unicode))

    def is_attributes(self, point):
        return isinstance(point, dict)

    def attributes(self, trackindex):
        '''Does the indicated track have attributes? Then return them.
        '''
        # Currently attributes are represented by a dictionary
        # as the next item after the name in the trackpoints list.
        if self.is_attributes(self.points[trackindex+1]):
            return self.points[trackindex+1]
        return None

    def handle_track_point(self, lat, lon, ele=None, waypoint_name=False,
                           timestamp=None):
        '''Add a new trackpoint or waypoint after some basic sanity checks.
           If waypoint_name, we assume this is a waypoint,
           otherwise assume it's a track point.
        '''
        if lon < self.minlon:
            self.minlon = lon
        if lon > self.maxlon:
            self.maxlon = lon
        if lat < self.minlat:
            self.minlat = lat
        if lat > self.maxlat:
            self.maxlat = lat

        point = [lon, lat]

        if waypoint_name:
            point.append(waypoint_name)

        if ele:
            point.append(ele)

        if timestamp:
            point.append({ "time": timestamp })
        # Note: GPX files imported from KML may have no timestamps.

        if waypoint_name:
            self.waypoints.append(point)
        else:
            self.points.append(point)

    def get_ele(self, pt):
        """Get the saved elevation of a point, if any.
        """
        if len(pt) < 3:
            return None
        ele = pt[2]
        if (isinstance(ele, str) or isinstance(ele, unicode)):
            return ele
        return None

    def get_timestamp(self, pt):
        """Does the point have a dict with a time element? If so, return it.
        """
        d = pt[-1]
        if type(d) is not dict:
            return None
        if "time" not in d:
            return None
        return d["time"]

    def read_track_file(self, filename):
        """Read a track file. Throw IOError if the file doesn't exist."""
        # XXX Should read magic number rather than depending on extension
        if filename.lower().endswith('.kml') or \
           filename.lower().endswith('.kmz'):
            return self.read_track_file_KML(filename)
        elif filename.lower().endswith('json'):
            return self.read_track_file_GeoJSON(filename)
        return self.read_track_file_GPX(filename)

    def read_track_file_GPX(self, filename):
        """Read a GPX track file. Throw IOError if the file doesn't exist."""
        global Debug

        if not os.path.exists(filename):
            raise IOError("Can't open track file %s" % filename)

        if (Debug):
            print "Using track file", filename

        if (Debug):
            print "Reading track file", filename
        dom = xml.dom.minidom.parse(filename)

        # Handle track(s).
        segs = dom.getElementsByTagName("trkseg")
        for seg in segs:
            trkpts = seg.getElementsByTagName("trkpt")

            # need to keep different track files and segments separate -- don't
            # draw lines from the end of one track to the beginning of the next.
            if trkpts:
                # See if the parent track has a name.
                trk = seg
                while trk.nodeName != "trk":
                    trk = trk.parentNode
                trkname = trk.getElementsByTagName("name")
                if trkname and \
                   trkname[0].hasChildNodes() and \
                   trkname[0].firstChild.nodeName == '#text' and \
                   trkname[0].firstChild.wholeText:
                    self.points.append(trkname[0].firstChild.wholeText)
                else:
                    self.points.append(os.path.basename(filename))

                for pt in trkpts:
                    # self.handle_track_pointGPX(pt, False)
                    lat, lon, ele, ts = self.GPX_point_coords(pt)
                    self.handle_track_point(lat, lon, ele, None, timestamp=ts)

        # Handle waypoints
        waypts = dom.getElementsByTagName("wpt")
        if waypts:
            self.waypoints.append(os.path.basename(filename))
            for pt in waypts:
                lat, lon, ele, time = self.GPX_point_coords(pt)
                name = "WP"
                name = self.get_DOM_text(pt, "name")
                self.handle_track_point(lat, lon, ele, name, timestamp=time)

        # GPX also allows for routing, rtept, but I don't think we need those.

    def get_DOM_text(self, node, childname=None):
        '''Get the text out of a DOM node.
           Or, if childname is specified, get the text out of a child
           node with node name childname.
        '''
        # print "get_DOM_text", node
        if childname:
            nodes = node.getElementsByTagName(childname)
            # print "node has", len(nodes), childname, "children"
            if not nodes:
                return None
            node = nodes[0]
        if not node:
            return None
        n = node.childNodes
        if len(n) >= 1 and n[0].nodeType == n[0].TEXT_NODE:
            return n[0].data
        return None

    def GPX_point_coords(self, point):
        '''Add a new trackpoint or waypoint from a GPX node'''
        lat = float(point.getAttribute("lat"))
        lon = float(point.getAttribute("lon"))
        ele = self.get_DOM_text(point, "ele")
        time = self.get_DOM_text(point, "time")
        # For now, keep elevation and time as unchanged strings.
        return lat, lon, ele, time

    def save_GPX(self, filename):
        '''Save all known tracks and waypoints as a GPX file.
           XXX We don't have valid <time> saved for these points.
        '''
        with open(filename, "w") as outfp:
            print >>outfp, '''<?xml version='1.0' encoding='UTF-8' standalone='yes' ?>
<gpx version="1.1" creator="PyTopo %s~" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
''' % Version
            if self.points:
                print >>outfp, "  <trk>"
                started = False
                for pt in self.points:
                    if self.is_start(pt):
                        if started:
                            print >>outfp, "    </trkseg>"
                        else:
                            started = True
                        print >>outfp, "    <trkseg>"
                    else:
                        print >>outfp, '      <trkpt lat="%f" lon="%f">' % (pt[1], pt[0])
                        ele = self.get_ele(pt)
                        if ele:
                            print >>outfp, '        <ele>%s</ele>' % ele
                        ts = self.get_timestamp(pt)
                        if ts:
                            print >>outfp, '        <time>%s</time>' % ts
                        print >>outfp, '      </trkpt>'
                print >>outfp, "    </trkseg>"
                print >>outfp, "  </trk>"

            for pt in self.waypoints:
                if self.is_start(pt):
                    continue
                print >>outfp, '''  <wpt lat="%f" lon="%f">
    <time>2015-12-02T16:50:34Z</time>
    <name>%s</name>
  </wpt>''' % (pt[1], pt[0], pt[2])

            print >>outfp, "</gpx>"

    def read_track_file_GeoJSON(self, filename):
        """Read a GeoJSON track file.
        """
        with open(filename) as fp:
            gj = simplejson.loads(fp.read())
        if gj["type"] != "FeatureCollection":
            print filename, "isn't a FeatureCollection"
            return
        if "features" not in gj:
            print "No features in geojson file", filename
            return
        for feature in gj["features"]:
            type = feature["geometry"]["type"]
            if type != "LineString" and type != "MultiLineString":
                continue
            # It's a track. Add it.
            name = None
            propstring = ""
            if "properties" in feature:
                props = feature["properties"]
                for key in props:
                    kl = key.lower()
                    if kl == "name" or kl == "trailname":
                        name = props[key]

            # Properties may specify a null name, but we need something.
            if not name:
                name = "unnamed"

            if type == "LineString":
                self.points.append(name)
                if "properties" in feature:
                    self.points.append(feature["properties"])
                for coords in feature["geometry"]["coordinates"]:
                    lon, lat, ele = coords
                    self.handle_track_point(lat, lon, ele, None)
            elif type == "MultiLineString":
                for linestring in feature["geometry"]["coordinates"]:
                    self.points.append(name)
                    if "properties" in feature:
                        self.points.append(feature["properties"])
                    for coords in linestring:
                        lon, lat, ele = coords
                        self.handle_track_point(lat, lon, ele, None)

    def read_track_file_KML(self, filename):
        """Read a KML or KMZ track file.
           Just read Placemarks (which cover both paths and points);
           ignore all styles.
           Throw IOError if the file doesn't exist.
        """
        global Debug

        if not os.path.exists(filename):
            raise IOError("Can't open track file %s" % filename)

        if (Debug):
            print "Reading track file", filename

        # Handle kmz compressed files, which are much more common in practice
        # than actual KML files:
        if filename.lower().endswith(".kmz") and zipfile.is_zipfile(filename):
            zip = zipfile.ZipFile(filename)
            namelist = zip.namelist()
            if "doc.kml" not in namelist:
                raise ValueError("No doc.kml in %s" % filename)
            if len(namelist) > 1:
                print "Warning: ignoring files other than doc.kml in", filename
            kmlfp = zip.open("doc.kml")
            doc_kml = kmlfp.read()
            kmlfp.close()
            dom = xml.dom.minidom.parseString(doc_kml)
            doc_kml = None
        else:
            dom = xml.dom.minidom.parse(filename)

        # Features we care about are <Placemark> containing either
        # <LineString> (tracks) or <Point> (waypoints).
        # A Placemark also contains <name>The name</name>,
        # Placemarks are apparently grouped inside a <Document>
        # but let's not worry about that now.

        placemarks = dom.getElementsByTagName("Placemark")
        for placemark in placemarks:
            # Try to get a trail name.
            name = None
            try:
                name = placemark.getElementsByTagName("name")[0].childNodes[0].data.strip()
            except:
                # no <name> tag, try for more esoteric schemes.
                # Lynn's USFS trail data has a scheme like
                # <ExtendedData><SchemaData ...><<SimpleData name="TrailName">
                # where the name might be TrailName or TrailNam_1
                try:
                    sdata = placemark.getElementsByTagName("ExtendedData")[0].getElementsByTagName("SimpleData")
                    for tag in sdata:
                        if tag.getAttribute("name").startswith("TrailNam"):
                            name = tag.childNodes[0].data.strip()
                            break
                except:
                    pass

            # Handle tracks:
            if not name:
                name = "unnamed"
            linestrings = placemark.getElementsByTagName("LineString")
            for linestring in linestrings:
                coord_triples = self.get_KML_coordinates(linestring)
                if not coord_triples:
                    continue
                self.points.append(name)
                for triple in coord_triples:
                    self.handle_track_point(triple[1], triple[0], triple[2],
                                            None)

            # Handle waypoints:
            if not name:
                name = "WP"
            points = placemark.getElementsByTagName("Point")
            for point in points:
                coord_triples = self.get_KML_coordinates(point)
                for triple in coord_triples:
                    if len(triple) == 3:
                        self.handle_track_point(triple[1], triple[0], triple[2],
                                                name)
                    elif len(triple) == 2:
                        self.handle_track_point(triple[1], triple[0], None,
                                                name)

    def get_KML_coordinates(self, el):
        '''Get the contents of the first <coordinates> triple
           inside the given element (which is inside a KML file).
           Inside a LineString, coordinate pairs or triples are separated
           by whitespace, which may include newlines.
           Return a list of triples [[lat, lon, ele], [lat, lon, ele] ...]
           Not all KMLs have elevation, so use None in that case.
        '''
        coords = el.getElementsByTagName("coordinates")
        if not coords or len(coords) < 1:
            return None
        coord_triples = coords[0].childNodes[0].data.strip().split()
        ret = []
        for s in coord_triples:
            triple = s.split(',')
            triple = map(float, triple)
            if len(triple) == 2:
                triple.append(None)
            ret.append(triple)

        return ret

class MapUtils:

    """MapUtils really just exists to contain a bunch of utility
       functions useful for mapping classes.
    """

    @classmethod
    def coord2str_dd(cls, lon, lat):
        """Convert a longitude, latitude pair into a pretty string,
           in decimal degrees"""
        s = "%.7f E  " % lon
        if lat >= 0:
            s += "%.7f N" % lat
        else:
            s += "%.57 S" % -lat
        return s

    @classmethod
    def deg_min2dec_deg(cls, coord):
        """Convert degrees.minutes to decimal degrees"""
        deg = cls.int_trunc(coord)
        dec = (coord - deg) / .6
        return deg + dec

    @classmethod
    def dec_deg2deg_min(cls, coord):
        """Convert decimal degrees to degrees.minutes"""
        if coord < 0:
            sgn = -1
            coord = -coord
        else:
            sgn = 1
        deg = cls.int_trunc(coord)
        min = abs(coord - deg) * .6
        return sgn * (deg + min)

    @classmethod
    def dec_deg2deg_min_str(cls, coord):
        """Convert decimal degrees to a nice degrees/minutes string"""
        if coord < 0:
            sgnstr = '-'
            coord = -coord
        else:
            sgnstr = ''
        deg = cls.int_trunc(coord)
        min = abs(coord - deg) * 60.
        min = cls.truncate2frac(min, .01)
        return sgnstr + str(deg) + "^" + str(min) + "'"

    @classmethod
    def angle_to_bearing(cls, angle):
        return (450 - angle) % 360

    # Convert an angle (deg) to the appropriate quadrant string, e.g. N 57 E.
    @classmethod
    def angle_to_quadrant(cls, angle):
        if angle > 180:
            angle = angle - 360
        if angle == 0:
            return "N"
        if angle == -90:
            return "W"
        if angle == 90:
            return "E"
        if angle == 180:
            return "S"
        if angle > -90 and angle < 90:
            if angle < 0:
                return "N " + str(-angle) + " W"
            return "N " + str(angle) + " E"
        if angle < 0:
            return "S " + str(180 + angle) + " W"
        return "S " + str(180 - angle) + " E"

    @classmethod
    def int_trunc(cls, num):
        """Truncate to an integer, but no .999999 stuff"""
        return int(num + .00001)

    @classmethod
    def truncate2frac(cls, num, frac):
        """Truncate to a multiple of the given fraction"""
        t = float(MapUtils.int_trunc(num / frac)) * frac
        if num < 0:
            t = t - frac
        return t

    @classmethod
    def ohstring(cls, num, numdigits):
        """Return a zero-prefixed string of the given number of digits."""
        fmt = '%%0%dd' % numdigits
        return fmt % num

    @classmethod
    def haversine_distance(cls, latitude_1, longitude_1,
                                latitude_2, longitude_2):
        """
        Haversine distance between two points, expressed in meters.
        From https://github.com/tkrajina/gpxpy/blob/master/gpxpy/geo.py
        Implemented from http://www.movable-type.co.uk/scripts/latlong.html
        """
        d_lat = math.radians(latitude_1 - latitude_2)
        d_lon = math.radians(longitude_1 - longitude_2)
        lat1 = math.radians(latitude_1)
        lat2 = math.radians(latitude_2)

        a = math.sin(d_lat/2) * math.sin(d_lat/2) + \
            math.sin(d_lon/2) * math.sin(d_lon/2) * \
            math.cos(lat1) * math.cos(lat2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        EARTH_RADIUS = 3959.     # miles
        d = EARTH_RADIUS * c

        return d

    @classmethod
    def distance_on_unit_sphere(cls, lat1, long1, lat2, long2):
        '''Linear distance between two points on a globe, in km.
           Divide by 1.609 to get miles.
        '''
        # Thanks http://www.johndcook.com/blog/python_longitude_latitude/

        # Convert latitude and longitude to 
        # spherical coordinates in radians.
        degrees_to_radians = math.pi/180.0

        # phi = 90 - latitude
        phi1 = (90.0 - lat1)*degrees_to_radians
        phi2 = (90.0 - lat2)*degrees_to_radians

        # theta = longitude
        theta1 = long1*degrees_to_radians
        theta2 = long2*degrees_to_radians

        # Compute spherical distance from spherical coordinates.

        # For two locations in spherical coordinates
        # (1, theta, phi) and (1, theta', phi')
        # cosine( arc length ) =
        #    sin phi sin phi' cos(theta-theta') + cos phi cos phi'
        # distance = rho * arc length

        cos = (math.sin(phi1)*math.sin(phi2)*math.cos(theta1 - theta2) +
               math.cos(phi1)*math.cos(phi2))
        arc = math.acos( cos )

        # Remember to multiply arc by the radius of the earth
        # in your favorite set of units to get length.
        return arc * 6373

# End of "MapUtils" pseudo-class.

class DownloadTileQueue:
    def __init__(self):
        self.queue = []    # Will be a list

    def __len__(self):
        return len(self.queue)

    # XXX we should perhaps use a set, for faster existence checking,
    # but then we wouldn't retain order.
    def push(self, url, path):
        """Push details for a new tile onto the queue if not already there.
        """
        for q in self.queue:
            if q[1] == path :  # Are paths the same? Already queued.
                return
        if path:
            self.queue.insert(0, [url, path])

    def pop(self):
        return self.queue.pop()

    def peek(self):
        return self.queue[-1]

class MapWindow():

    """The PyTopo UI: the map window.
This holds the GTK specific drawing code,
and is intended to be extensible into other widget libraries.
To that end, it needs to implement the following methods
that are expected by the MapCollection classes:
   win_width, win_height = get_size(), set_color(),
   draw_pixbuf(pixbuf, x_off, y_off, x, y, w, h)
   draw_rectangle(fill, x, y, width, height)
   draw_line(x, y, width, height)
(That list is very incomplete and needs to be updated, sorry.)
"""

    def __init__(self, _controller):
        """Initialize variables, but don't create the window yet."""

        # Save a reference to the PyTopo object that created this window.
        # We'll need it to change locations, collections etc.
        self.controller = _controller

        # The current map collection being used:
        self.collection = None

        self.center_lon = 0
        self.center_lat = 0
        self.cur_lon = 0
        self.cur_lat = 0
        self.trackpoints = None
        self.show_waypoints = True
        self.selected_track = None
        self.selected_waypoint = None

        self.win_width = 0
        self.win_height = 0

        self.traildialog = None

        try:
            self.pin = \
                gtk.gdk.pixbuf_new_from_file("/usr/share/pytopo/pytopo-pin.png")
        except:
            try:
                self.pin = gtk.gdk.pixbuf_new_from_file("pytopo-pin.png")
            except:
                self.pin = None
        self.pin_lon = 0
        self.pin_lat = 0
        self.pin_xoff = -4
        self.pin_yoff = -12

        # Print distances in metric?
        # This should be set externally!
        self.use_metric = False

        # Where to save generated maps. The default is fine for most people.
        # Which is a good thing since there's currently no way to change it.
        self.map_save_dir = os.path.expanduser("~/Topo/")

        # X/gtk graphics variables we need:
        self.drawing_area = 0
        self.xgc = 0

        self.click_last_long = 0
        self.click_last_lat = 0

        # Context menus don't seem to have any way of passing the location
        # initially clicked. So save x and y on right mouse down.
        self.context_x = None
        self.context_y = None

        self.is_dragging = False

        # The timeout for long press events
        self.press_timeout = None

        # Colors and fonts should of course be configurable:
        # self.bg_color = gtk.gdk.color_parse("black")
        self.black_color = gtk.gdk.color_parse("black")
        self.red_color = gtk.gdk.color_parse("red")
        self.bg_scale_color = gtk.gdk.color_parse("white")
        self.first_track_color = gtk.gdk.color_parse("magenta")
        self.waypoint_color = gtk.gdk.color_parse("blue2")
        self.grid_color = gtk.gdk.color_parse("grey45")

        self.font_desc = pango.FontDescription("Sans 9")
        self.wpt_font_desc = pango.FontDescription("Sans Italic 10")
        self.attr_font_desc = pango.FontDescription("Sans Bold Italic 12")
        self.select_font_desc = pango.FontDescription("Sans Bold 15")

    def show_window(self, init_width, init_height):
        """Create the initial window."""
        win = gtk.Window()
        win.set_name("PyTopo")
        win.connect("destroy", self.graceful_exit)
        win.set_border_width(5)

        vbox = gtk.VBox(spacing=3)
        win.add(vbox)

        self.drawing_area = gtk.DrawingArea()
        # There doesn't seem to be any way to resize a window below
        # the initial size of the drawing area. So make the drawing area
        # initially tiny, then just before showing we'll resize the window.
        # self.drawing_area.size(10, 10)
        vbox.pack_start(self.drawing_area)

        self.drawing_area.set_events(gtk.gdk.EXPOSURE_MASK |
                                     gtk.gdk.POINTER_MOTION_MASK |
                                     gtk.gdk.POINTER_MOTION_HINT_MASK |
                                     gtk.gdk.BUTTON_PRESS_MASK |
                                     gtk.gdk.BUTTON_RELEASE_MASK )

        self.drawing_area.connect("expose-event", self.expose_event)
        self.drawing_area.connect("button-press-event", self.mousepress)
        self.drawing_area.connect("button-release-event", self.mouserelease)
        self.drawing_area.connect("scroll-event", self.scroll_event)
        self.drawing_area.connect("motion_notify_event", self.drag_event)

        # The default focus in/out handlers on drawing area cause
        # spurious expose events.  Trap the focus events, to block that:
        # XXX can we pass "pass" in to .connect?
        self.drawing_area.connect("focus-in-event", self.nop)
        self.drawing_area.connect("focus-out-event", self.nop)

        # Handle key presses on the drawing area.
        # If seeing spurious expose events, try setting them on win instead,
        # and comment out gtk.CAN_FOCUS.
        self.drawing_area.set_flags(gtk.CAN_FOCUS)
        self.drawing_area.connect("key-press-event", self.key_press_event)

        # Resize the window now to the desired initial size:
        win.resize(init_width, init_height)

        win.show_all()

        gtk.main()

    #
    # Draw maplets to fill the window, centered at center_lon, center_lat
    #
    def draw_map(self):
        """Redraw the map, centered at center_lon, center_lat."""
        global Debug

        if self.collection == None:
            print "No collection!"
            return
        if not self.drawing_area:
            # Not initialized yet, not ready to draw a map
            return

        self.win_width, self.win_height = self.drawing_area.window.get_size()

        # XXX Collection.draw_map wants center, but we only have lower right.
        if (Debug):
            print ">>>>>>>>>>>>>>>>"
            print "window draw_map centered at",
            print MapUtils.dec_deg2deg_min_str(self.center_lon),
            print MapUtils.dec_deg2deg_min_str(self.center_lat)
        self.collection.draw_map(self.center_lon, self.center_lat, self)

        self.draw_trackpoints()

        if not self.is_dragging:
            self.draw_zoom_control()

        # Is there a selected track?
        def draw_selected_label(name, labelstring, x, y):
            tracklabel = labelstring + name

            layout = self.drawing_area.create_pango_layout(tracklabel)
            layout.set_font_description(self.select_font_desc)
            label_width, label_height = layout.get_pixel_size()
            self.xgc.set_rgb_fg_color(self.red_color)
            self.drawing_area.window.draw_layout(self.xgc,
                                                 self.win_width-label_width-x,
                                                 y,
                                                 layout)

        if self.selected_track != None:
            draw_selected_label(self.trackpoints.points[self.selected_track],
                                "Track: ", 15, 15)
        if self.selected_waypoint != None:
            draw_selected_label(self.trackpoints.waypoints[self.selected_waypoint][2], "Waypoint: ", 15, 40)

        # Copyright info or other attribution
        self.set_color(self.grid_color)
        self.collection.draw_attribution(self)

        # draw pin
        pin_x, pin_y = self.coords2xy(self.pin_lon, self.pin_lat,
                                      self.win_width, self.win_height)

        if self.pin:
            self.draw_pixbuf(self.pin, 0,0,pin_x+self.pin_xoff,
                             pin_y+self.pin_yoff,-1,-1)

        self.draw_map_scale()

    def contrasting_color(self, color):
        '''Takes a gtk.gdk.Color (RGB values 0:65535)
           and converts it to a similar saturation and value but different hue
        '''
        if not color:
            return self.first_track_color;

        # Hue is a floating point between 0 and 1. How much should we jump?
        jump = .37

        return gtk.gdk.color_from_hsv(color.hue + jump,
                                      color.saturation, color.value)

    def draw_trackpoint_segment(self, start, linecolor, linewidth=3,
                                linestyle=gtk.gdk.LINE_ON_OFF_DASH):
        '''Draw a trackpoint segment, starting at the given index.
           Stop drawing if we reach another start string, and return the index
           of that string. Return None if we reach the end of the list.
        '''
        self.set_color(linecolor)
        self.xgc.line_style = linestyle
        self.xgc.line_width = linewidth
        cur_x = None
        cur_y = None
        i = start
        if self.trackpoints.is_start(self.trackpoints.points[i]):
            # This should be true
            i += 1

        while True:
            if i >= len(self.trackpoints.points):
                return None
            pt = self.trackpoints.points[i]
            if self.trackpoints.is_start(pt):
                return i
            i += 1

            # Skip over dictionaries of attributes
            if self.trackpoints.is_attributes(pt):
                continue

            x = int((pt[0] - self.center_lon) * self.collection.xscale
                    + self.win_width/2)
            y = int((self.center_lat - pt[1]) * self.collection.yscale
                    + self.win_height/2)

            if ((x >= 0 and x < self.win_width and
                 y >= 0 and y < self.win_height) or
                (cur_x < self.win_width and cur_y < self.win_height)):
                if cur_x != None and cur_y != None:
                    # self.set_color(self.track_color)
                    self.draw_line(cur_x, cur_y, x, y)
                    # self.set_color(self.black_color)
                    # self.draw_circle(True, x, y, 3)

                cur_x = x
                cur_y = y
            else:
                # It's off the screen. Skip it.
                #print "Skipping", pt[0], pt[1], \
                #    ": would be", x, ",", y
                cur_x = None
                cur_y = None

    def select_track(self, trackindex):
        if Debug:
            # Test against None specifically, else we won't be able
            # to select the first track starting at index 0.
            if trackindex != None:
                print "Selecting track starting at", trackindex
            else:
                print "De-selecting track"
        self.selected_track = trackindex

        if not trackindex:
            return

        # Does the selected track have attributes? If so, pop up a dialog.
        attrs = self.trackpoints.attributes(trackindex)
        if not attrs:
            return

        # Pop up a dialog showing attributes.
        attrstr = '\n'.join(["%s: %s" % (key, attrs[key]) for key in attrs])
        self.show_traildialog(attrstr)

    def show_traildialog(self, attrstr):
        trailname = self.trackpoints.points[self.selected_track]
        if not self.traildialog:
            self.traildialog = gtk.Dialog(trailname,
                                          None, 0,
                                          (gtk.STOCK_CLOSE,
                                           gtk.RESPONSE_CANCEL))
            self.traildialog.set_size_request(400, 300)

            sw = gtk.ScrolledWindow()
            sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
            sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

            textview = gtk.TextView()
            self.attributes_textbuffer = textview.get_buffer()
            sw.add(textview)
            sw.show()
            textview.show()
            self.traildialog.vbox.pack_start(sw, expand=True)
            self.traildialog.connect("response", self.hide_traildialog)

        else:
            self.traildialog.set_title(trailname)

        self.attributes_textbuffer.set_text("== %s ==\n%s" % (trailname,
                                                              attrstr))

        self.traildialog.show_all()

    def hide_traildialog(self, d, responseid=None):
        d.hide()

    def draw_trackpoints(self):
        if not self.trackpoints:
            return

        # Now draw any trackpoints that are visible.
        # self.trackpoints may be trackpoints or waypoints
        self.track_color = None

        # win_width, win_height = self.drawing_area.window.get_size()
        if len(self.trackpoints.points) > 0:
            cur_x = None
            cur_y = None

            next = 0
            while True:
                self.track_color = self.contrasting_color(self.track_color)
                next = self.draw_trackpoint_segment(next, self.track_color)
                if not next:
                    break

        if self.selected_track != None:  # None vs. trackpoint 0
            self.draw_trackpoint_segment(self.selected_track,
                                         self.red_color, linewidth=6)

        if self.show_waypoints and len(self.trackpoints.waypoints) > 0:
            self.set_color(self.waypoint_color)
            self.xgc.line_style = gtk.gdk.LINE_SOLID
            self.xgc.line_width = 2
            for pt in self.trackpoints.waypoints:
                if self.trackpoints.is_start(pt) or \
                   self.trackpoints.is_attributes(pt):
                    continue
                x = int((pt[0] - self.center_lon) * self.collection.xscale
                        + self.win_width/2)
                y = int((self.center_lat - pt[1]) * self.collection.yscale
                        + self.win_height/2)

                if x >= 0 and x < self.win_width and \
                   y >= 0 and y < self.win_height:
                    layout = self.drawing_area.create_pango_layout(pt[2])
                    layout.set_font_description (self.wpt_font_desc)
                    # tw = layout.get_size()[0] / pango.SCALE
                    th = layout.get_size()[1] / pango.SCALE
                    self.drawing_area.window.draw_layout(self.xgc,
                                                         x + th/3,
                                                         y - th/2,
                                                         layout)
                    self.draw_rectangle(True, x-3, y-3, 6, 6)

    def find_nearest_trackpoint(self, x, y):
        """Find the nearet track, the nearest point on that track,
           and the nearest waypoint (if any) to a given x, y point.
           Any of the three can be None if nothing is sufficiently close.
           Coords x, y passed in are screen coordinates;
           if None, we'll assume exact center, as if we've already
           set center_lat and center_lon after a mouse click.

           @return: (nearest_track,    Starting point of the nearest track
                    nearest_point,    Index of nearest point on that track
                    nearest_waypoint) Nearest waypoint
        """
        nearest_track = None
        nearest_point = None
        nearest_waypoint = None

        halfwidth, halfheight = \
            [ s/2 for s in self.drawing_area.window.get_size()]
        if x == None:
            x = halfwidth
        if y == None:
            y = halfheight
        CLOSE = 6    # pixels

        if not self.trackpoints:
            return None, None, None

        def closer_dist(pt, sm_dist):
            """Return distance from pt to x, y --
               but only if it's smaller than sm_dist.
            """
            # tx = int((pt[0] - self.center_lon) * self.collection.xscale
            #          + halfwidth)
            # ty = int((self.center_lat - pt[1]) * self.collection.yscale
            #          + halfheight)

            tx, ty = self.coords2xy(pt[0], pt[1],
                                    self.win_width, self.win_height)

            if abs(x - tx) > CLOSE or abs(y - ty) > CLOSE:
                return None

            dist = math.sqrt((x-tx)**2 + (y-ty)**2)
            if dist < sm_dist:
                return dist
            return None

        # Find closest waypoint
        if self.trackpoints.waypoints:
            smallest_dist = CLOSE * 8
            for i, pt in enumerate(self.trackpoints.waypoints):
                if self.trackpoints.is_start(pt) or \
                   self.trackpoints.is_attributes(pt):
                    continue
                d = closer_dist(pt, smallest_dist)
                if d:
                    smallest_dist = d
                    nearest_waypoint = i

        # Find closest track and index of the closest point on the track
        if len(self.trackpoints.points) > 0:
            smallest_dist = CLOSE * 8
            for i, pt in enumerate(self.trackpoints.points):
                if self.trackpoints.is_start(pt):
                    track_start = i
                    lastx = None
                    lasty = None
                    continue

                if self.trackpoints.is_attributes(pt):
                    continue

                d = closer_dist(pt, smallest_dist)
                if d:
                    smallest_dist = d
                    nearest_point = i
                    nearest_track = track_start

                """
                # Okay, the click wasn't on a point. Is it on
                # a line between this point and the last one?
                if lastx and lasty:
                    m = float(y-lasty) / float(x-lastx)
                    y1 = m * x + lasty  # Predicted position
                    if abs(y - y1) < CLOSE:
                        self.select_track(track_start)
                        return
                """
        return nearest_track, nearest_point, nearest_waypoint

    def draw_map_scale(self):
        ########################################################################
        #
        # The draw_map_scale function calculates and draws a map scale at the
        # bottom of the map window created by the PyTopo mapping application.
        # Distances are calculated along the surface of the geoid defined by the
        # earth equitorial radius, Req, and the square of the eccentricity of
        # the earth, esq.
        # The map scale is accurate only for the center latitude of the map.
        # The circumference of the earth at the equator is 24901 miles (an upper
        # limit on map size).
        # USGS quadrangles use NAD-27, but WGS-84 is the most recent datum, and
        # GPS uses WGS-84.
        #
        # References:
        #    http://en.wikipedia.org/wiki/Geodetic_system
        #    http://www.gmat.unsw.edu.au/snap/gps/clynch_pdfs/radiigeo.pdf
        #
        # Copyright (C) 2013 Spencer A. Buckner
        #
        ########################################################################

        # Define constants
        # Req = 6.3781370e+06   # WGS-84 earth equatorial radius (meters)
        # esq = 6.694380e-03    # WGS-84 square of eccentricity of earth
        Req = 6.3782064e+06   # NAD-27 earth equatorial radius (meters)
        esq = 6.768658e-03    # NAD-27 square of eccentricity of earth

        # Calculate pixels per mile and pixels per kilometer at map center
        lat_deg = self.center_lat
        lat_rad = lat_deg*math.pi/180
        sin_lat = math.sin(lat_rad)
        sin_lat_sq = sin_lat*sin_lat
        cos_lat = math.cos(lat_rad)
        R_meters = Req/math.sqrt(1 - esq*sin_lat_sq)             # earth radius (m)
        R_miles = R_meters/(0.0254*12*5280)                      # earth radius (miles)
        R_km = R_meters/1000	                                   # earth radius (km)
        xscale_deg = self.collection.xscale                      # pixels per degree
        xscale_mi = xscale_deg*360/(2*math.pi*R_miles*cos_lat)   # pixels per mile
        xscale_km = xscale_deg*360/(2*math.pi*R_km*cos_lat)      # pixels per km

        ##################################################

        # Calculate window width in miles and kilometers
        width_mi = self.win_width/xscale_mi   # (miles)
        width_km = self.win_width/xscale_km   # (kilometers)

        # Calculate length of map-scale bars in pixels;
        # length (pixels) <= self.win_width/2.
        log_width = math.log10(width_mi/2)
        power_10 = math.floor(log_width)
        fraction = log_width - power_10
        log10_1 = 0
        log10_2 = math.log10(2)
        log10_5 = math.log10(5)
        log10_10 = 1
        if log10_1 <= fraction and fraction < log10_2:
            length = 1*math.pow(10, power_10)   # (miles or kilometers)
            nticks = 6
        elif log10_2 <= fraction and fraction < log10_5:
            length = 2*math.pow(10, power_10)   # (miles or kilometers)
            nticks = 5
        elif log10_5 <= fraction and fraction < log10_10:
            length = 5*math.pow(10, power_10)   # (miles or kilometers)
            nticks = 6
        length_mi = xscale_mi*length   # (pixels)
        length_km = xscale_km*length   # (pixels)
        label_mi = str(10)
        label_km = str(10)
        label_mi = '\0'*len(label_mi)
        label_km = '\0'*len(label_km)
        label_mi = "%g mi" %length
        label_km = "%g km" %length

        ##################################################

        # Calculate coordinates of miles map-scale bar
        x1 = int((self.win_width - length_mi)/2 + 0.5)
        y1 = int(self.win_height - 30 + 0.5)
        x2 = int(x1 + length_mi + 0.5)
        y2 = y1

        # Get label length in pixels;
        # length of "0" string is 7.
        layout = self.drawing_area.create_pango_layout (label_mi)
        layout.set_font_description (self.font_desc)
        width, height = layout.get_pixel_size ()
        str_length_mi = width

        # Draw white background for miles map-scale
        self.xgc.line_style = gtk.gdk.LINE_SOLID
        self.set_color(self.bg_scale_color)
        self.xgc.line_width = 20
        self.draw_line(x1-10-7-10, y1, x2+10+str_length_mi+10, y2)

        # Draw miles map-scale bar
        self.set_bg_color()
        self.xgc.line_width = 1
        self.draw_line(x1, y1, x2, y2)

        # Draw tick marks on miles map-scale bar
        x0 = x1
        for i in range(nticks):
            x1 = x0 + int(i*length_mi/(nticks - 1) + 0.5)
            x2 = x1
            self.draw_line(x1, y1-3, x2, y2+3)

        # Draw miles map-scale labels
        x = x0 - 10 - 7
        y = self.win_height - 36
        self.draw_string_scale(x, y, "0")
        x = x2 + 10
        self.draw_string_scale(x, y, label_mi)

        ##################################################

        # Calculate coordinates of kilometers map-scale bar
        x1 = int((self.win_width - length_km)/2 + 0.5)
        y1 = int(self.win_height - 10 + 0.5)
        x2 = int(x1 + length_km + 0.5)
        y2 = y1

        # Get label length in pixels;
        # length of "0" string is 7.
        layout = self.drawing_area.create_pango_layout (label_km)
        layout.set_font_description (self.font_desc)
        width, height = layout.get_pixel_size ()
        str_length_km = width

        # Draw white background for kilometers map-scale
        self.xgc.line_style = gtk.gdk.LINE_SOLID
        self.set_color(self.bg_scale_color)
        self.xgc.line_width = 20
        self.draw_line(x1-10-7-10, y1, x2+10+str_length_km+10, y2)

        # Draw kilometers map-scale bar
        self.set_bg_color()
        self.xgc.line_width = 1
        self.draw_line(x1, y1, x2, y2)

        # Draw tick marks on kilometers map-scale bar
        x0 = x1
        for i in range(nticks):
            x1 = x0 + int(i*length_km/(nticks - 1) + 0.5)
            x2 = x1
            self.draw_line(x1, y1-3, x2, y2+3)

        # Draw kilometers map-scale labels
        x = x0 - 10 - 6
        y = self.win_height - 16
        self.draw_string_scale(x, y, "0")
        x = x2 + 10
        self.draw_string_scale(x, y, label_km)

    def draw_zoom_control(self):
        """Draw some zoom controls in case we're running on a tablet
           and have no keyboard to zoom or move around.
           Also draw any other controls we might need.
        """
        self.zoom_btn_size = int(self.win_width / 25)
        self.zoom_X1 = 8
        self.zoom_in_Y1 = 10
        self.zoom_out_Y1 = self.zoom_in_Y1 + self.zoom_btn_size * 2
        textoffset = self.zoom_btn_size / 5

        self.xgc.line_style = gtk.gdk.LINE_SOLID
        self.set_color(self.grid_color)
        self.xgc.line_width = 3

        # Draw the boxes
        self.draw_rectangle(False, self.zoom_X1, self.zoom_in_Y1,
                            self.zoom_btn_size, self.zoom_btn_size)
        self.draw_rectangle(False, self.zoom_X1, self.zoom_out_Y1,
                            self.zoom_btn_size, self.zoom_btn_size)

        midpointx = self.zoom_X1 + self.zoom_btn_size/2
        # Draw the -
        midpointy = self.zoom_out_Y1 + self.zoom_btn_size/2
        self.draw_line(self.zoom_X1 + textoffset, midpointy,
                       self.zoom_X1 + self.zoom_btn_size - textoffset,
                       midpointy)

        # Draw the +
        midpointy = self.zoom_in_Y1 + self.zoom_btn_size/2
        self.draw_line(self.zoom_X1 + textoffset, midpointy,
                       self.zoom_X1 + self.zoom_btn_size - textoffset,
                       midpointy)
        self.draw_line(midpointx, self.zoom_in_Y1 + textoffset,
                       midpointx,
                       self.zoom_in_Y1 + self.zoom_btn_size - textoffset)

    def was_click_in_zoom(self, x, y):
        """Do the coordinates fall within the zoom in or out buttons?
           Returns 0 for none, 1 for zoom in, -1 for zoom out.
        """
        if x < self.zoom_X1 or x > self.zoom_X1 + self.zoom_btn_size:
            return 0
        if y < self.zoom_in_Y1 or y > self.zoom_out_Y1 + self.zoom_btn_size:
            return 0
        if y < self.zoom_in_Y1 + self.zoom_btn_size:
            return 1
        if y > self.zoom_out_Y1:
            return -1
        # Must be between buttons
        return 0

    def print_location(self, widget=None):
        print MapUtils.coord2str_dd(self.cur_lon, self.cur_lat)
        print "%-15s %-15s" % (MapUtils.dec_deg2deg_min_str(self.cur_lon),
                             MapUtils.dec_deg2deg_min_str(self.cur_lat))

    def zoom(self, widget=None):
        self.center_lon = self.cur_lon
        self.center_lat = self.cur_lat
        self.collection.zoom(1)
        self.draw_map()

    def scroll_event(self, button, event):
        if event.direction != gtk.gdk.SCROLL_UP and \
           event.direction != gtk.gdk.SCROLL_DOWN:
            return False

        if event.direction == gtk.gdk.SCROLL_UP:
            direc = 1
        else:
            direc = -1

        # Save off the coordinates currently under the mouse,
        # so we can arrange for it to be under the mouse again after zoom.
        curmouselon, curmouselat = self.xy2coords(event.x, event.y,
                                                  self.win_width,
                                                  self.win_height)

        self.collection.zoom(direc)

        # What are the coordinates for the current mouse pos after zoom?
        newmouselon, newmouselat = self.xy2coords(event.x, event.y,
                                                  self.win_width,
                                                  self.win_height)
        # Shift the map over so the old point will be under the mouse.
        self.center_lon += (curmouselon - newmouselon)
        self.center_lat += (curmouselat - newmouselat)

        self.draw_map()
        return True

    def context_menu(self, event):
        '''Create a context menu. This is called anew on every right-click.'''

        contextmenu = collections.OrderedDict([
            ( MapUtils.coord2str_dd(self.cur_lon, self.cur_lat),
              self.print_location),
            ( "Zoom here...", self.zoom),
            ( "Go to pin...", self.set_center_to_pin),
            ( "Pin this location", self.set_pin_by_mouse),
            ( "Save pin location...", self.save_location),
            ( "Split track here", self.split_track_by_mouse),
            ( "My Locations...", self.mylocations),
            ( "My Tracks...", self.mytracks),
            ( "Download Area...", self.download_area),
            ( "Show waypoints...", self.toggle_show_waypoints),
            ( "Save GPX...", self.save_tracks_as),
            ( "Change background map", self.change_collection),
            ( "Quit", self.graceful_exit)
            ])

        menu = gtk.Menu()
        for itemname in contextmenu.keys():
            item = gtk.MenuItem(itemname)

            # Show/Hide waypoints changes its name since it's a toggle:
            if contextmenu[itemname] == self.toggle_show_waypoints:
                if self.show_waypoints:
                    item.set_label("Hide waypoints...")
                item.connect("activate", contextmenu[itemname])

            # Change background map gives a submenu of available collections.
            elif itemname == "Change background map":
                submenu = gtk.Menu()
                for coll in self.controller.collections:
                    subitem = gtk.MenuItem(coll.name)
                    subitem.connect("activate", self.change_collection,
                                    coll.name)
                    submenu.append(subitem)
                    subitem.show()
                item.set_submenu(submenu)

            elif contextmenu[itemname]:
                item.connect("activate", contextmenu[itemname])

            # Would be nice to make the menu item not selectable,
            # but this greys it out and makes it hard to read.
            # else:
            #     item.set_sensitive(False)

            menu.append(item)
            item.show()

        if event:
            button = event.button
            t = event.time
        else:
            button = 3
            t = 0
            # There's no documentation on what event.time is: it's
            # "the time of the event in milliseconds" -- but since when?
            # Not since the epoch.
        menu.popup(None, None, None, button, t)

    def change_collection(self, widget, name):
        newcoll = self.controller.find_collection(name)
        if newcoll:
            newcoll.zoom_to(self.collection.zoomlevel, self.cur_lat)
            self.collection = newcoll
            self.draw_map()
        else:
            print "Couldn't find a collection named '%s'" % name

    def toggle_show_waypoints(self, widget):
        self.show_waypoints = not self.show_waypoints
        self.draw_map()

    def mylocations(self, widget):
        self.controller.location_select(self)

    def save_tracks_as(self, widget):
        '''Prompt for a filename to save all tracks and waypoints.'''
        dialog = gtk.FileChooserDialog(title="Save GPX",
                                       action=gtk.FILE_CHOOSER_ACTION_SAVE,
                                       buttons=(gtk.STOCK_CANCEL,
                                                  gtk.RESPONSE_CANCEL,
                                                gtk.STOCK_SAVE,
                                                  gtk.RESPONSE_OK))
        dialog.set_current_folder(self.controller.config_dir)
        filter = gtk.FileFilter()
        filter.set_name("GPX Files")
        filter.add_pattern("*.gpx")
        dialog.add_filter(filter)

        while True:
            response = dialog.run()

            if response != gtk.RESPONSE_OK:
                dialog.destroy()
                return

            outfile = dialog.get_filename()
            if os.path.exists(outfile):
                d = gtk.MessageDialog(None, gtk.DIALOG_MODAL,
                                      gtk.MESSAGE_QUESTION,
                                      gtk.BUTTONS_YES_NO)

                d = gtk.MessageDialog(None, 0,
                                      gtk.MESSAGE_QUESTION,
                                      gtk.BUTTONS_YES_NO,
                                      "File exists. Overwrite?")
                d.set_default_response(gtk.RESPONSE_YES)

                response = d.run()
                d.destroy()

                if response != gtk.RESPONSE_YES:
                    continue
                else:
                    break
            else:
                break

        # At this point we have a filename, and either it's unique
        # or we've confirmed overwriting.
        # Now save all our tracks and waypoints as a GPX file in outfile.
        dialog.destroy()
        if Debug:
            print "Saving GPX to", outfile
        self.trackpoints.save_GPX(outfile)

    def split_track_by_mouse(self, widget):
        """Split a track at the current mouse location."""

        self.draw_map()
        near_track, near_point, near_waypoint = \
            self.find_nearest_trackpoint(self.context_x, self.context_y)

        if near_point != None:
            # Make a name for the new track segment
            trackname = self.trackpoints.points[near_track]
            match = re.search('(.*) (\d+)$', trackname)
            if match:
                trackname = "%s %d" % (match.group(1), int(match.group(2))+1)
            else:
                trackname += " 2"

            # Split the track there
            self.trackpoints.points.insert(near_point, trackname)

        self.draw_map()

    def set_pin_by_mouse(self, widget):
        """Set the pin at the current mouse location"""
        self.pin_lon, self.pin_lat = self.cur_lon, self.cur_lat
        self.draw_map()

    def set_center_to_pin(self, widget):
        """Set the center at the current pin point"""
        self.center_lon, self.center_lat = self.pin_lon, self.pin_lat
        self.draw_map()

    def save_location(self, widget):
        """Save the pinned location.
        XXX should save zoom level too, if different from collection default.
        """
        dialog = gtk.Dialog("Save location", None, 0,
                            (gtk.STOCK_CANCEL, gtk.RESPONSE_NONE,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        dialog.set_size_request(200, 150)
        dialog.vbox.set_spacing(10)

        prompt = gtk.Label("Please specify a name:")
        dialog.vbox.pack_start(prompt, expand=False)
        nametext = gtk.Entry()
        dialog.vbox.pack_start(nametext, expand=True)
        comment = gtk.Label("")
        dialog.vbox.pack_start(comment, expand=False)

        dialog.show_all()

        while True:
            response = dialog.run()
            if response == gtk.RESPONSE_OK:
                name = nametext.get_text().strip()
                if not name:
                    comment.set_text("Name can't be empty")
                    continue

                # Add to KnownSites
                self.controller.append_known_site( [name,
                    MapUtils.dec_deg2deg_min(self.pin_lon),
                    MapUtils.dec_deg2deg_min(self.pin_lat),
                    self.collection.name,
                    self.collection.zoomlevel] )

                dialog.destroy()
                return True
            else:
                dialog.destroy()
                return True

    def mytracks(self, widget):
        self.controller.track_select(self)
        if self.trackpoints != None:
            self.trackpoints_center()
        self.draw_map()

    def trackpoints_center(self):
        minlon, minlat, maxlon, maxlat = self.trackpoints.get_bounds()
        self.center_lon = (maxlon + minlon) / 2
        self.center_lat = (maxlat + minlat) / 2

    def cancel_download(self, widget, data=None):
        self.cancelled = True

    def download_area(self, widget):
        global Debug
        if not self.collection.zoomlevel:
            print "Can't download an area for this collection"
            return

        # Get default values for area and zoom levels:
        halfwidth = self.win_width / self.collection.xscale / 2
        halfheight = self.win_height / self.collection.yscale / 2
        minlon = self.center_lon - halfwidth
        maxlon = self.center_lon + halfwidth
        minlat = self.center_lat - halfheight
        maxlat = self.center_lat + halfheight
        minzoom = self.collection.zoomlevel
        maxzoom = self.collection.zoomlevel + 4

        # Prompt the user for any adjustments to area and zoom:
        dialog = gtk.Dialog("Download an area", None, 0,
                            (gtk.STOCK_REFRESH, gtk.RESPONSE_APPLY,
                             gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        #dialog.set_size_request(200, 150)
        #dialog.vbox.set_spacing(10)
        frame = gtk.Frame("Current zoom = %d" % self.collection.zoomlevel)
        dialog.vbox.pack_start(frame, True, True, 0)

        table = gtk.Table(4, 3, False)
        table.set_border_width(5)
        table.set_row_spacings(5)
        table.set_col_spacings(10)
        frame.add(table)

        label = gtk.Label("Min longitude:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 0, 1, 0, 1,
                     gtk.SHRINK, 0, 0, 0)
        minlon_entry = gtk.Entry()
        table.attach(minlon_entry, 1, 2, 0, 1,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Max longitude:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 2, 3, 0, 1,
                     gtk.SHRINK, 0, 0, 0)
        maxlon_entry = gtk.Entry()
        table.attach(maxlon_entry, 3, 4, 0, 1,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Min latitude:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 0, 1, 1, 2,
                     gtk.SHRINK, 0, 0, 0)
        minlat_entry = gtk.Entry()
        table.attach(minlat_entry, 1, 2, 1, 2,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Max latitude:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 2, 3, 1, 2,
                     gtk.SHRINK, 0, 0, 0)
        maxlat_entry = gtk.Entry()
        table.attach(maxlat_entry, 3, 4, 1, 2,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Min zoom:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 0, 1, 2, 3,
                     gtk.SHRINK, 0, 0, 0)
        minzoom_entry = gtk.Entry()
        table.attach(minzoom_entry, 1, 2, 2, 3,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        label = gtk.Label("Max zoom:")
        label.set_justify(gtk.JUSTIFY_RIGHT)
        table.attach(label, 2, 3, 2, 3,
                     gtk.SHRINK, 0, 0, 0)
        maxzoom_entry = gtk.Entry()
        table.attach(maxzoom_entry, 3, 4, 2, 3,
                     gtk.EXPAND | gtk.FILL, 0, 0, 0)

        err_label = gtk.Label("")
        dialog.vbox.pack_start(err_label, True, True, 0)

        progress_label = gtk.Label("")
        dialog.vbox.pack_start(progress_label, True, True, 0)

        def flush_events():
            while gtk.events_pending():
                gtk.main_iteration(False)

        def reset_download_dialog():
            minlon_entry.set_text(str(minlon))
            maxlon_entry.set_text(str(maxlon))
            minlat_entry.set_text(str(minlat))
            maxlat_entry.set_text(str(maxlat))
            minzoom_entry.set_text(str(minzoom))
            maxzoom_entry.set_text(str(maxzoom))

        reset_download_dialog()

        dialog.show_all()

        self.cancelled = False

        while True:
            response = dialog.run()
            if response == gtk.RESPONSE_CANCEL:
                dialog.destroy()
                return True
            if response == gtk.RESPONSE_APPLY:
                reset_download_dialog()
                continue
            # Else the response must have been OK.
            # So connect the cancel button to cancel_download(),
            # which means first we have to find the cancel button:
            # Starting with PyGTK 2.22 we can use this easier method:
            #cancelBtn = dialog.get_widget_for_response(gtk.RESPONSE_OK)
            # but for now:
            buttons = dialog.get_action_area().get_children()
            for b in buttons:
                if b.get_label() == 'gtk-cancel':
                    b.connect("clicked", self.cancel_download, str)
                    break

            try:
                minlon = float(minlon_entry.get_text().strip())
                maxlon = float(maxlon_entry.get_text().strip())
                minlat = float(minlat_entry.get_text().strip())
                maxlat = float(maxlat_entry.get_text().strip())
                minzoom = int(minzoom_entry.get_text().strip())
                maxzoom = int(maxzoom_entry.get_text().strip())
                break

            except ValueError:
                err_label.set_text("Sorry, can't parse one of the values")
                continue

        if Debug:
            print "Downloading from %f - %f, %f - %f, zoom %d - %d" \
                % (minlon, maxlon, minlat, maxlat, minzoom, maxzoom)
        for zoom in range(minzoom, maxzoom+1):
            err_label.set_text("Downloading zoom level %d" % zoom)

            # Show a busy cursor on the dialog:
            busy_cursor = gtk.gdk.Cursor(gtk.gdk.WATCH)
            dialog.window.set_cursor(busy_cursor)
            flush_events()
            gtk.gdk.flush()

            if Debug:
                print "==== Zoom level", zoom

            # Find the start and end tiles
            (minxtile, minytile, x_off, y_off) = \
                self.collection.deg2num(maxlat, minlon, zoom)
            (maxxtile, maxytile, x_off, y_off) = \
                self.collection.deg2num(minlat, maxlon, zoom)
            if Debug:
                print "X tiles from", minxtile, "to", maxxtile
                print "Y tiles from", minytile, "to", maxytile

            pathlist = []
            for ytile in range(minytile, maxytile+1):
                for xtile in range(minxtile, maxxtile+1):
                    if Debug:
                        print "Tile", xtile, ytile,
                    filename = os.path.join(self.collection.location,
                                            str(zoom),
                                            str(xtile),
                                            str(ytile)) \
                                            + self.collection.ext
                    if os.access(filename, os.R_OK):
                        if Debug:
                            print filename, "is already there"
                        continue
                    pathlist.append(filename)
                    if Debug:
                        print "appended as", filename

            numtiles = len(pathlist)
            err_label.set_text("Zoom level %d: %d tiles" % (zoom, numtiles))
            flush_events()
            num_downloaded = 0

            for filename in pathlist:
                if self.cancelled:
                    dialog.destroy()
                    return True

                url = self.collection.url_from_path(filename, zoom)

                # XXX Parallelize this!
                if Debug:
                    print "Downloading", url, "to", filename
                thedir = os.path.dirname(filename)
                if not os.access(thedir, os.W_OK):
                    os.makedirs(thedir)
                #err_label.set_text("%d %%: %d of %d" % \
                #                   (int(num_downloaded*100 / numtiles),
                #                    num_downloaded, numtiles))
                if Debug:
                    print "%d %%: %d of %d" % \
                        (int(num_downloaded*100 / numtiles),
                         num_downloaded, numtiles)
                progress_label.set_text("%d: %s" % (num_downloaded, url))
                flush_events()
                urllib.urlretrieve(url, filename)
                num_downloaded += 1

                # XXX should show progress more graphically.

        dialog.destroy()
        return True

    #
    # Drawing-related routines:
    #

    def get_size(self):
        """Return the width and height of the canvas."""
        return self.drawing_area.window.get_size()

    def set_bg_color(self):
        """Change to the normal background color (usually black)."""
        #self.xgc.set_rgb_fg_color(self.bg_color)
        self.xgc.foreground = self.xgc.background

    def set_color(self, color):
        self.xgc.set_rgb_fg_color(color)

    def draw_pixbuf(self, pixbuf, x_off, y_off, x, y, w, h):
        """Draw the pixbuf at the given position and size,
        starting at the specified offset."""
        self.drawing_area.window.draw_pixbuf(self.xgc, pixbuf, x_off, y_off,
                                              x, y, w, h)
    def draw_rectangle(self, fill, x, y, w, h):
        """Draw a rectangle."""
        self.drawing_area.window.draw_rectangle(self.xgc, fill, x, y, w, h)

    def draw_line(self, x, y, x2, y2):
        """Draw a line."""
        self.drawing_area.window.draw_line(self.xgc, x, y, x2, y2)

    def draw_circle(self, fill, xc, yc, r):
        """Draw a circle, filled or not, centered at xc, yc with radius r."""
        self.drawing_area.window.draw_arc(self.xgc, fill, xc-r, yc-4,
                                          r*2, r*2, 0, 23040)  # 64 * 360

    def draw_string_scale(self, x, y, s, whichfont=None):
        """Draw a string at the specified location.
           If x or y is negative, we'll draw from the right or bottom edge.
           If whichfont is "waypoint" it'll be a little bigger and italic;
           if "attribution" even bigger and also italic;
           if it's "select" it'll be a lot bigger.
        """
        layout = self.drawing_area.create_pango_layout(s)
        if whichfont == "waypoint":
            layout.set_font_description (self.wpt_font_desc)
        elif whichfont == "attribution":
            layout.set_font_description (self.attr_font_desc)
        elif whichfont == "select":
            layout.set_font_description (self.select_font_desc)
        else:
            layout.set_font_description (self.font_desc)
        if x < 0 or y < 0:
            win_width, win_height = self.get_size()
            lw, lh = layout.get_pixel_size()
            if x < 0:
                x = win_width - lw + x
            if y < 0:
                y = win_height - lh + y
        self.drawing_area.window.draw_layout(self.xgc, x, y, layout)

    # Save the current map as something which could be gimped or printed.
    # XXX THIS IS BROKEN, code assumes start_lon/start_lat but has center_.
    def save_as(self):

        """Save a static map. Somewhat BROKEN, needs rewriting."""

        file_list = ""

        # Calculate dAngle in decimal degrees
        dAngle = self.collection.img_width / self.collection.xscale

        # Calculate number of charts based on window size, and round up
        # so the saved map shows at least as much as the window does.
        num_lon = int (.8 + float(self.win_width) / self.collection.img_width)
        num_lat = int (.8 + float(self.win_height) / self.collection.img_height)

        ny = 0
        curlat = self.center_lat + dAngle*num_lat * .25
        while ny < num_lat:
            curlon = self.center_lon - dAngle*num_lon * .25
            nx = 0
            while nx < num_lon:
                file_list += " " + \
                    self.collection.coords_to_filename(curlon, curlat)
                curlon += dAngle
                nx += 1
            curlat -= dAngle
            ny += 1

        outfile = self.map_save_dir + "topo" + "_" + \
                  str(self.center_lon) + "_" + str(self.center_lat) + ".gif"
        cmdstr = "montage -geometry 262x328 -tile " + \
                 str(nx) + "x" + str(ny) + " " + \
                 file_list + " " + outfile
        #print "Running:", cmdstr
        os.system(cmdstr)

        if (os.access(outfile, os.R_OK)):
            print "Saved:", outfile

    def expose_event(self, widget, event):
        """Handle exposes on the canvas."""
        #print "Expose:", event.type, "for object", self
        #print "area:", event.area.x, event.area.y, \
        #    event.area.width, event.area.height

        if self.xgc == 0:
            self.xgc = self.drawing_area.window.new_gc()
            #self.xgc.set_foreground(white)

        #x, y, w, h = event.area

        self.draw_map()

        return True

    def key_press_event(self, widget, event):
        """Handle any key press."""
        if event.string == "q":
            self.graceful_exit()
            # Must return here ... gtk.main_quit() (called from graceful_exit())
            # won't actually return immediately, so without a return
            # we'll fall through and end up drawing the map again
            # before exiting.
            return True
        elif event.string == "+" or event.string == "=":
            self.collection.zoom(1)
        elif event.string == "-":
            self.collection.zoom(-1)
        elif event.keyval == gtk.keysyms.Left:
            self.center_lon -= \
                float(self.collection.img_width) / self.collection.xscale
        elif event.keyval == gtk.keysyms.Right:
            self.center_lon += \
                float(self.collection.img_width) / self.collection.xscale
        elif event.keyval == gtk.keysyms.Up:
            self.center_lat += \
                float(self.collection.img_height) / self.collection.yscale
        elif event.keyval == gtk.keysyms.Down:
            self.center_lat -= \
                float(self.collection.img_height) / self.collection.yscale
        elif event.keyval == gtk.keysyms.space:
            self.set_center_to_pin()
        elif event.keyval == gtk.keysyms.l and \
                 event.state == gtk.gdk.CONTROL_MASK:
            pass    # Just fall through to draw_map()
        elif event.string == "m":
            if PyTopo.selection_window(p, self):
                self.set_center_to_pin()
                pass
        elif event.string == "s":
            self.save_as()
            return True
        else:
            #print "Unknown key,", event.keyval
            return False

        self.draw_map()
        return True

    def xy2coords(self, x, y, win_width, win_height, xscale=None, yscale=None):
        """Convert pixels to longitude/latitude."""
        # collection.x_scale is in pixels per degree.
        if not xscale:
            xscale = self.collection.xscale
        if not yscale:
            yscale = self.collection.yscale
        return (self.center_lon - \
                    float(win_width/2 - x) / xscale,
                self.center_lat + \
                    float(win_height/2 - y) / yscale)

    def coords2xy(self, lon, lat, win_width, win_height,
                  xscale=None, yscale=None):
        """Convert lon/lat to pixels."""
        if not xscale:
            xscale = self.collection.xscale
        if not yscale:
            yscale = self.collection.yscale
        return (int((lon - self.center_lon) * xscale
                    + win_width/2),
                int((self.center_lat - lat) * yscale
                    + win_height/2) )

    def drag_event(self, widget, event):
        """Move the map as the user drags."""

        if self.press_timeout:
            gobject.source_remove(self.press_timeout)
            self.press_timeout = None

        # On a tablet (at least the ExoPC), almost every click registers
        # as a drag. So if a drag starts in the zoom control area,
        # it was probably really meant to be a single click.
        if self.was_click_in_zoom(event.x, event.y):
            return False

        # The GTK documentation @ 24.2.1
        # http://www.pygtk.org/pygtk2tutorial/sec-EventHandling.html
        # says the first event is a real motion event and subsequent
        # ones are hints; but in practice, nothing but hints are
        # ever sent.
        if event.is_hint:
            x, y, state = event.window.get_pointer()
        else:
            x = event.x
            y = event.y
            state = event.state
        if not state & gtk.gdk.BUTTON1_MASK:
            return False
        if not self.is_dragging:
            self.x_start_drag = x
            self.y_start_drag = y
            self.is_dragging = True
        self.move_to(x, y, widget)
        return True

    def move_to(self, x, y, widget):
        if widget.drag_check_threshold(self.x_start_drag, self.y_start_drag,
                                       x, y):
            dx = x - self.x_start_drag
            dy = y - self.y_start_drag
            self.center_lon -= dx / self.collection.xscale
            self.center_lat += dy / self.collection.yscale
            self.draw_map()
            # Reset the drag coordinates now that we're there
            self.x_start_drag = x
            self.y_start_drag = y

    def mousepress(self, widget, event):
        """Handle mouse button presses"""

        # We're either about to add a new timeout, or not time out
        # because we had a doubleclick. Either way, remove any
        # existing timeout:
        if self.press_timeout:
            gobject.source_remove(self.press_timeout)
            self.press_timeout = None

        # Was it a right click?
        if event.button == 3:
            x, y, state = self.drawing_area.window.get_pointer()
            self.context_x = x
            self.context_y = y
            self.cur_lon, self.cur_lat = self.xy2coords(x, y,
                                                        self.win_width,
                                                        self.win_height)
            self.context_menu(event)
            return

        # If it wasn't a double click, set a timeout for LongPress
        if event.type != gtk.gdk._2BUTTON_PRESS:
            self.press_timeout = gobject.timeout_add(1000, self.longpress)
            return False

        # Zoom in if we get a double-click.
        self.center_lon, self.center_lat = self.xy2coords(event.x, event.y,
                                           self.win_width, self.win_height)

        self.collection.zoom(1)
        self.draw_map()
        return True

    def longpress(self):
        if self.press_timeout:
            gobject.source_remove(self.press_timeout)
            self.press_timeout = None
        x, y, state = self.drawing_area.window.get_pointer()
        self.cur_lon, self.cur_lat = self.xy2coords(x, y,
                                                    self.win_width,
                                                    self.win_height)
        self.context_menu(None)
        return True

    def mouserelease(self, widget, event):
        """Handle button releases."""

        # print "Setting context coords to", self.context_x, self.context_y
        if self.press_timeout:
            gobject.source_remove(self.press_timeout)
            self.press_timeout = None
            #return False

        if self.is_dragging:
            self.is_dragging = False
            x, y, state = event.window.get_pointer()
            self.move_to(x, y, widget)
            self.draw_zoom_control()
            return True

        if event.button == 1:
            global Debug

            zoom =  self.was_click_in_zoom(event.x, event.y)
            if zoom:
                self.collection.zoom(zoom)
                self.draw_map()
                return True

            # Is this needed for anything?
            # It breaks passing location to context menus.
            # cur_long, cur_lat = self.xy2coords(event.x, event.y,
            #                                    self.win_width, self.win_height)
            if Debug:
                print "Click:", \
                    MapUtils.dec_deg2deg_min_str(cur_long), \
                    MapUtils.dec_deg2deg_min_str(cur_lat)

            # Find angle and distance since last click.
            if Debug or event.state & gtk.gdk.SHIFT_MASK:
                if self.click_last_long != 0 and self.click_last_lat != 0:
                    dist = MapUtils.distance_on_unit_sphere(self.click_last_lat,
                                                           self.click_last_long,
                                                            cur_lat, cur_long)
                    dist2 = MapUtils.haversine_distance(self.click_last_lat,
                                                           self.click_last_long,
                                                            cur_lat, cur_long)
                    if self.use_metric:
                        print "Distance: %.2f km" % dist
                    else:
                        print "Distance: %.2f mi" % (dist / 1.609)
                        print "Haversine Distance: %.2f mi" % dist2

                    # Now calculate bearing. I don't know how accurate this is.
                    xdiff = (cur_long - self.click_last_long)
                    ydiff = (cur_lat - self.click_last_lat)
                    angle = int(math.atan2(-ydiff, -xdiff) * 180 / math.pi)
                    angle = MapUtils.angle_to_bearing(angle)
                    print "Bearing:", angle, "=", \
                        MapUtils.angle_to_quadrant(angle)
            # self.click_last_long = cur_long
            # self.click_last_lat = cur_lat

            # Is the click near a track or waypoint we're displaying?
            near_track, near_point, near_waypoint = \
                self.find_nearest_trackpoint(event.x, event.y)
            if near_track != None:
                self.select_track(near_track)
            else:
                self.select_track(None)
            if near_waypoint != None:
                self.selected_waypoint = near_waypoint
            else:
                self.selected_waypoint = None

            self.draw_map()

        return True

    @staticmethod
    def nop(*args):
        "Do nothing."
        return True

    def graceful_exit(self, extra=None):
        """Clean up the window and exit.
           The "extra" argument is so it can be calld from GTK callbacks.
        """
        self.controller.save_sites() # Tell PyTopo to save any new sites/tracks

        gtk.main_quit()
        # The python profilers don't work if you call sys.exit here.

        # Too bad, because gtk.main_quit() doesn't actually exit
        # until later. So any function that calls this must be sure
        # to guard against anything like extra map redraws.
#
# End of MapWindow class
#

class PyTopo:

    """A class to hold the mechanics of running the PyTopo program,
    plus some important variables including Collections and KnownSites.
    """

    def __init__(self):
        self.collections = []
        self.KnownSites = []
        self.KnownTracks = []
        self.init_width = 800
        self.init_height = 600
        self.default_collection = None
        self.needs_saving = False
        self.config_dir = os.path.expanduser("~/.config/pytopo",)
        self.savefilename = os.path.join(self.config_dir, "saved.sites")
        self.reload_tiles = False

    @classmethod
    def Usage(cls):
        global VersionString
        print VersionString
        print """
Usage: pytopo [-t trackfile] [-c collection] [-r] [site_name]
           -r : re-download all map tiles
       pytopo [-t trackfile] start_lat start_long collection
       pytopo -p : list known sites and tracks
       pytopo -h : print this message

Use degrees.decimal_minutes format for coordinates.
Set up site names in ~/.config/pytopo.sites, track logs in ~/Tracks.

Track files may contain track points and/or waypoints;
multiple track files are allowed.

Move around using arrow keys.  q quits.
Click in the map to print the coordinates of the clicked location.
's' will attempt to save the current map as a GIF file in ~/Topo/."""
        sys.exit(1)

    @classmethod
    def error_out(cls, errstr):
        """Print an error and exit cleanly."""
        print "==============="
        print errstr
        print "===============\n"
        PyTopo.Usage()

    def append_known_site(self, site):
        self.KnownSites.append(site)
        self.needs_saving = True

    def save_sites(self):
        """Write any new KnownSites to file.
           Should only be called from graceful exit.
        """
        if not self.needs_saving:
            return

        try:
            savefile = open(self.savefilename, "w")
        except:
            print "Couldn't open save file", self.savefilename
            return

        for site in self.KnownSites[self.first_saved_site:]:
            # All sites have a string, two floats and another string;
            # some sites may have additional ints after that.
            print >>savefile, '[ "%s", %f, %f, "%s"' % \
                (site[0], site[1], site[2], site[3]),
            if len(site) > 4:
                print >>savefile, ', ' + ', '.join(map(str, site[4:])),
            print >>savefile, "]"
        savefile.close()

    def print_sites(self):
        """Print the list of known sites."""
        print "Known Sites:"
        for site in self.KnownSites:
            print " ", site[0], "(", os.path.basename(site[3]), ")"
        print
        print "Known Tracks:"
        for track in self.KnownTracks:
            print " ", track[0]
        sys.exit(0)

    def find_collection(self, collname):
        """Find a collection with the given name."""
        global Debug

        #print "Looking for a collection named", collname
        # Make sure collname is a MapCollection we know about:
        collection = None
        for coll in self.collections:
            if collname == coll.name:
                if not coll.exists():
                    PyTopo.error_out("Can't access location " + coll.location +
                                     " for collection " + collname)
                collection = coll
                if (Debug):
                    print "Found the collection", collection.name
                return collection
        return collection

    def selection_window(self, mapwin):
        '''Show a window that lets the user choose a known starting point.
        '''
        dialog = gtk.Dialog("Choose a point", None, 0,
                            (gtk.STOCK_CLOSE, gtk.RESPONSE_NONE,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        #dialog.connect('destroy', lambda win: gtk.main_quit())
        dialog.set_size_request(400, 300)

        sw = gtk.ScrolledWindow()
        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        # List store will hold name, collection-name and site object
        store = gtk.ListStore(str, str, object)

        # Create the list
        for site in self.KnownSites:
            store.append([site[0], site[3], site])

        # http://pygtk.org/pygtk2tutorial/ch-TreeViewWidget.html
        # Make a treeview from the list:
        treeview = gtk.TreeView(store)

        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Location", renderer, text=0)
        #column.pack_start(renderer, True)
        #column.set_resizable(True)
        treeview.append_column(column)
        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Collection", renderer, text=1)
        #column.pack_start(renderer, False)
        treeview.append_column(column)

        #store.set_sort_column_id(0, gtk.SORT_ASCENDING)

        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.add(treeview)

        dialog.vbox.pack_start(sw, expand=True)

        dialog.show_all()

        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            selection = treeview.get_selection()
            model, iter = selection.get_selected()
            if iter:
                #locname = store.get_value(iter, 0)
                #collname = store.get_value(iter, 1)
                site = store.get_value(iter, 2)
                self.use_site(site, mapwin)
                dialog.destroy()
                return True
        else:
            dialog.destroy()
        return False

    def track_select(self, mapwin):
        dialog = gtk.Dialog("Tracks", None, 0,
                            (gtk.STOCK_CLOSE, gtk.RESPONSE_NONE,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        dialog.set_size_request(400, 300)

        sw = gtk.ScrolledWindow()
        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        # List store will hold Track name and Track file path
        store = gtk.ListStore(str, str)

        # Create the list
        for track in self.KnownTracks:
            store.append([ track[0], track[1] ])

        treeview = gtk.TreeView(store)

        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Track name", renderer, text=0)
        treeview.append_column(column)

        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.add(treeview)

        dialog.vbox.pack_start(sw, expand=True)

        dialog.show_all()

        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            selection = treeview.get_selection()
            model, iter = selection.get_selected()
            if iter:
                trackfile = store.get_value(iter, 1)
                mapwin.trackpoints = TrackPoints()
                mapwin.trackpoints.read_track_file(trackfile)
                # XXX Might want to handle IOError in case file doesn't exist
                dialog.destroy()
                return True
        else:
            dialog.destroy()
        return False

    def location_select(self, mapwin):
        dialog = gtk.Dialog("Locations", None, 0,
                            (gtk.STOCK_REMOVE, gtk.RESPONSE_APPLY,
                             gtk.STOCK_CLOSE, gtk.RESPONSE_NONE,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))
        dialog.set_size_request(400, 300)

        sw = gtk.ScrolledWindow()
        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        # List store will hold name, collection-name and site object
        store = gtk.ListStore(str, str, object)

        # Create the list
        for site in self.KnownSites:
            store.append([site[0], site[3], site])

        # Make a treeview from the list:
        treeview = gtk.TreeView(store)

        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Location", renderer, text=0)
        treeview.append_column(column)
        renderer = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Collection", renderer, text=1)
        treeview.append_column(column)

        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.add(treeview)

        dialog.vbox.pack_start(sw, expand=True)

        dialog.show_all()

        response = dialog.run()
        while response == gtk.RESPONSE_APPLY:
            selection = treeview.get_selection()
            model, iter = selection.get_selected()
            if iter:
                site = store.get_value(iter, 2)
                self.KnownSites.remove(site)
                store.remove(iter)
            response = dialog.run()

        if response == gtk.RESPONSE_OK:
            selection = treeview.get_selection()
            model, iter = selection.get_selected()
            if iter:
                site = store.get_value(iter, 2)
                self.use_site(site, mapwin)
                dialog.destroy()
                return True
        else:
            dialog.destroy()
        return False

    def use_site(self, site, mapwin):
        collection = self.find_collection(site[3])
        if not collection:
            return False
        mapwin.collection = collection

        # site[1] and site[2] are the long and lat in deg.minutes
        #print site[0], site[1], site[2]
        mapwin.center_lon = MapUtils.deg_min2dec_deg(site[1])
        mapwin.center_lat = MapUtils.deg_min2dec_deg(site[2])
        mapwin.pin_lon = mapwin.center_lon
        mapwin.pin_lat = mapwin.center_lat
        #print "Center in decimal degrees:", centerLon, centerLat
        if (Debug):
            print site[0] + ":", \
                MapUtils.dec_deg2deg_min_str(mapwin.center_lon), \
                MapUtils.dec_deg2deg_min_str(mapwin.center_lat)
        if len(site) > 4 and collection.zoom_to:
            collection.zoom_to(site[4])
        mapwin.draw_map()
        return True

    def parse_args(self, mapwin, args):
        """Parse runtime arguments."""
        global VersionString
        global Debug

        # Variables we expect from .pytopo:
        do_collection = False

        arg0 = args[0]
        args = args[1:]

        while len(args) > 0:
            if args[0][0] == '-' and not args[0][1].isdigit():
                if args[0] == "-v" or args[0] == "--version":
                    print VersionString
                    sys.exit(0)
                elif args[0] == "-h" or args[0] == "--help":
                    PyTopo.Usage()

                # Next clause is impossible because of the prev isdigit check:
                #if args[0] == "-15":
                #    series = 15
                elif args[0] == "-p":
                    self.print_sites()
                elif args[0] == "-c":
                    # Specify a collection:
                    if len(args) < 2:
                        print "-c must specify collection"
                        PyTopo.Usage()
                    mapwin.collection = self.find_collection(args[1])
                    if mapwin.collection == None:
                        PyTopo.error_out("I can't find a map collection called "
                                        + args[1])
                    # Start initially at top left, but subsequent args
                    # may change this:
                    mapwin.center_lon, mapwin.center_lat = \
                        mapwin.collection.get_top_left()
                    if (Debug):
                        print "Collection", mapwin.collection.name,
                        print "Starting at", \
                            MapUtils.dec_deg2deg_min_str(mapwin.center_lon), \
                            ", ", MapUtils.dec_deg2deg_min_str(mapwin.center_lat)
                    args = args[1:]

                elif args[0] == "-d":
                    Debug = True
                elif args[0] == "-r":
                    self.reload_tiles = time.time()
                elif args[0] == "-t" and len(args) > 1:
                    if mapwin.trackpoints == None:
                        mapwin.trackpoints = TrackPoints()

                    # Is it a known track?
                    for tr in self.KnownTracks:
                        if args[1] == tr[0]:
                            if Debug:
                                print "Reading known track", tr[0], tr[1]
                            args[1] = tr[1]
                            break

                    try:
                        mapwin.trackpoints.read_track_file(args[1])
                    except IOError:
                        print "Can't read track file", args[1]
                    args = args[1:]
                else:
                    PyTopo.error_out("Unknown flag " + args[0])

                # Done processing this flag
                args = args[1:]
                continue

            # args[0] doesn't start with '-'. Is it a track file?
            if args[0].endswith(".gpx") \
               or args[0].endswith(".kml") \
               or args[0].endswith(".kmz") \
               or args[0].endswith("json"):
                try:
                    if mapwin.trackpoints:
                        mapwin.trackpoints.read_track_file(args[0])
                    else:
                        trackpoints = TrackPoints()
                        trackpoints.read_track_file(args[0])
                        mapwin.trackpoints = trackpoints
                except IOError:
                    print "Can't read track file", args[0]
                except xml.parsers.expat.ExpatError:
                    print "Can't read %s: syntax error." % args[0]
                    if args[0].lower().endswith(".kml") or \
                       args[0].lower().endswith(".kmz"):
                        print """
Is this a KML made with ArcGIS?
It may have an illegal xsi:schemaLocation.
If so, try changing xsi:schemaLocation to just schemaLocation."""
                args = args[1:]
                continue

            # Try to match a known site:
            for site in self.KnownSites:
                if args[0] == site[0]:
                    if not self.use_site(site, mapwin):
                        continue
                    break

            if mapwin.collection and mapwin.center_lon and mapwin.center_lat:
                args = args[1:]
                continue

            # Doesn't match a known site. Maybe the args are coordinates?
            try:
                if len(args) >= 2 and \
                   len(args[0]) > 1 and args[0][1].isdigit() and \
                   len(args[1]) > 1 and args[1][1].isdigit():
                    mapwin.center_lon = MapUtils.deg_min2dec_deg(float(args[0]))
                    mapwin.center_lat = MapUtils.deg_min2dec_deg(float(args[2]))
                    mapwin.collection = self.find_collection(args[3])
                    args = args[2:]
                    continue
                print "Can't make sense of argument:", args[0]
                PyTopo.Usage()

            except ValueError, e:
                print "Couldn't parse coordinates"
                PyTopo.Usage()

            # If we get here, we still have an argument but it doesn't
            # match anything we know: flag, collection, site or coordinate.
            print "Problem parsing arguments. Remaining args:", args
            PyTopo.Usage()

        # Now we've parsed all the arguments.
        # If we didn't get a collection, use the default, if any:
        if not mapwin.collection and self.default_collection:
            mapwin.collection = self.find_collection(self.default_collection)

        # If we have a collection and a track but no center point,
        # center it on the trackpoints, and set scale appropriately:
        if mapwin.trackpoints != None and mapwin.collection != None \
                and not (mapwin.center_lat and mapwin.center_lon):
            minlon, minlat, maxlon, maxlat = mapwin.trackpoints.get_bounds()
            mapwin.center_lon = (maxlon + minlon) / 2
            mapwin.center_lat = (maxlat + minlat) / 2
            mapwin.collection.zoom_to_bounds(minlon, minlat, maxlon, maxlat)

        if self.reload_tiles and 'set_reload_tiles' in dir(mapwin.collection):
            mapwin.collection.set_reload_tiles(self.reload_tiles)
        elif self.reload_tiles:
            print "Collection can't re-download tiles"

        # By now, we hope we have the mapwin positioned with a collection
        # and starting coordinates:
        if mapwin.collection and mapwin.center_lon and mapwin.center_lat:
            return

        # Didn't match any known run mode:
        # start in GUI mode choosing a location:
        if not self.selection_window(mapwin):
            sys.exit(0)

# Check for a user config file named .pytopo
# in either $HOME/.config/pytopo or $HOME.
#
# Format of the user config file:
# It is a python script, which can include arbitrary python code,
# but the most useful will be KnownSites definitions,
# with coordinates specified in degrees.decimal_minutes,
# like this:
# MapHome = "/cdrom"
# KnownSites = [
#     # Death Valley
#     [ "zabriskie", 116.475, 36.245, "dv_data" ],
#     [ "badwater", 116.445, 36.125, "dv_data" ],
#     # East Mojave
#     [ "zzyzyx", 116.05, 35.08, "emj_data" ]
#     ]

    def exec_config_file(self):
        """Load the user's .pytopo config file,
        found either in $HOME/.config/pytopo/ or $HOME/pytopo.
        """
        userfile = os.path.join(self.config_dir, "pytopo.sites")
        if not os.access(userfile, os.R_OK):
            if Debug:
                print "Couldn't open", userfile
            userfile = os.path.expanduser("~/.pytopo")
            if not os.access(userfile, os.R_OK):
                if Debug:
                    print "Couldn't open", userfile, "either"
                userfile = os.path.join(self.config_dir, "pytopo", ".pytopo")
                if not os.access(userfile, os.R_OK):
                    if Debug:
                        print "Couldn't open", userfile, "either"
                    userfile = self.create_initial_config()
                    if userfile == None:
                        print "Couldn't create a new pytopo config file"
                        return
                else:
                    print "Suggestion: rename", userfile, \
                          "to ~/.config/pytopo/pytopo.sites"
                    print userfile, "may eventually be deprecated"
        if Debug:
            print "Found", userfile

        # Now we'd better have a userfile

        # Now that we're in a function inside the PyTopo class, we can't
        # just execfile() and set a variable inside that file -- the file
        # can only change it inside a "locals" dictionary.
        # So set up the dictionary:
        locals =  { 'Collections' : [ 3, 4 ],
                    'KnownSites' : [],
                    'init_width' : self.init_width,
                    'init_height' : self.init_height
                  }
        execfile(userfile, globals(), locals)

        # Then extract the changed values back out:
        self.collections = locals['Collections']
        self.KnownSites = locals['KnownSites']
        self.init_width = locals["init_width"]
        self.init_height = locals["init_height"]
        self.default_collection = locals["defaultCollection"]

    def read_saved_sites(self):
        """Read previously saved (favorite) sites."""
        global Debug
        try:
            savefile = open(self.savefilename, "r")
        except:
            return

        # A line typically looks like this:
        # [ "san-francisco", -121.750000, 37.400000, "openstreetmap" ]
        # or, with an extra optional zoom level,
        # [ "san-francisco", -121.750000, 37.400000, "openstreetmap", 11 ]

        r = re.compile('\["([^"]*)",([-0-9\.]*),([-0-9\.]*),"([^"]*)",?([0-9]+)?\]')
        for line in savefile:
            # First remove all whitespace:
            line = re.sub(r'\s', '', line)
            match = r.search(line)
            if match:
                matches = match.groups()
                # Convert from strings to numbers
                site = [ matches[0], float(matches[1]), float(matches[2]),
                         matches[3] ]
                if len(matches) == 5 and matches[4] != None:
                    site.append(int(matches[4]))
                if Debug:
                    print "Adding", site[0], "to KnownSites"
                self.KnownSites.append( site )

        savefile.close()

    def read_tracks(self):
        trackdir = os.path.expanduser('~/Tracks')

        if os.path.isdir(trackdir):
            for file in glob.glob( os.path.join(trackdir, '*.gpx') ):
                head, gpx = os.path.split(file)
                filename = gpx.partition('.')[0]
                self.KnownTracks.append( [filename, file] )

    def create_initial_config(self):
        """Make an initial configuration file.
           If the user has a ~/.config, make ~/.config/pytopo/pytopo.sites
           else fall back on ~/.pytopo.
        """
        confdir = os.path.expanduser("~/.config/pytopo")
        try:
            if not os.access(confdir, os.W_OK):
                os.mkdir(confdir)
            userfile = os.path.join(confdir, "pytopo.sites")
            fp = open(userfile, 'w')
        except:
            fp = None
        if not fp:
            userfile = os.path.expanduser("~/.pytopo")
            try:
                fp = open(userfile, 'w')
            except:
                return None

        # Now we have fp open. Write a very basic config to it.
        print >>fp, """# Pytopo site file

# Map collections

Collections = [
    OSMMapCollection( "openstreetmap", "~/Maps/openstreetmap",
                      ".png", 256, 256, 10,
                      "http://a.tile.openstreetmap.org" ),

    # You will need an API key to get the excellent OpenCycleMap tiles
    # from http://thunderforest.com.
    # OSMMapCollection( "opencyclemap", "~/Maps/opencyclemap",
    #                   ".png", 256, 256, 13,
    #                   "https://tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey=YOUR_API_KEY_HERE",
    #                   maxzoom=22, reload_if_older=60,  # reload if > 60 days
    #                   attribution="Maps  www.thunderforest.com, Data  www.osm.org/copyright"),
    ]

defaultCollection = "openstreetmap"

KnownSites = [
    # Some base values to get new users started.
    # Note that these coordinates are a bit northwest of the city centers;
    # they're the coordinates of the map top left, not center.
    [ "san-francisco", -121.75, 37.4, "openstreetmap" ],
    [ "new-york", -73.466, 40.392, "openstreetmap" ],
    [ "london", 0.1, 51.266, "openstreetmap" ],
    [ "sydney", 151.0, -33.5, "openstreetmap" ],
    ]
"""
        fp.close()

        print """Welcome to Pytopo!
Created an initial site file in %s
You can add new sites and collections there; see the instructions at
   http://shallowsky.com/software/topo/
""" % (userfile)
        return userfile

    def main(self, pytopo_args):
        """main execution routine for pytopo."""
        self.exec_config_file()
        # Remember how many known sites we got from the config file;
        # the rest are read in from saved sites and may need to be re-saved.
        self.first_saved_site = len(self.KnownSites)
        self.read_saved_sites()
        self.read_tracks()
        gc.enable()

        mapwin = MapWindow(self)

        self.parse_args(mapwin, pytopo_args)

        # For cProfile testing, run with a dummy collection (no data needed):
        #mapwin.collection = MapCollection("dummy", "/tmp")

        #print cProfile.__file__
        #cProfile.run('mapwin.show_window()', 'cprof.out')
        # http://docs.python.org/library/profile.html
        # To analyze cprof.out output, do this:
        # import pstats
        # p = pstats.Stats('fooprof')
        # p.sort_stats('time').print_stats(20)

        mapwin.show_window(self.init_width, self.init_height)

#####################################################################
# Some global routines that really should get moved into a class:
#

# A relatively clean way of downloading files in a separate thread.
# http://code.activestate.com/recipes/577129-run-asynchronous-tasks-using-coroutines/
#
def start_job(generator):
    """Start a job (a coroutine that yield generic tasks)."""
    def _task_return(result):
        """Function to be sent to tasks to be used as task_return."""
        def _advance_generator():
            try:
                new_task = generator.send(result)
            except StopIteration:
                return
            new_task(_task_return)
        # make sure the generator is advanced in the main thread
        gobject.idle_add(_advance_generator)
    _task_return(None)
    return generator

import threading
gobject.threads_init()

def threaded_task(function, *args, **kwargs):
    """Run function(*args, **kwargs) inside a thread and return the result."""
    def _task(task_return):
        def _thread():
            result = function(*args, **kwargs)
            gobject.idle_add(task_return, result)
        thread = threading.Thread(target=_thread, args=())
        thread.setDaemon(True)
        thread.start()
    return _task

def download_job(url, localpath, callback):
    def download(url, localpath, callback):
        global magic_parser
        if Debug:
            print "Downloading", url
            print "  to", localpath
        try:
            urllib.urlretrieve(url, localpath)
        except IOError, e:
            print "Couldn't download", url, ":"
            print e
            return None

        if magic_parser == None:
            try:
                import magic
                magic_parser = magic.open(magic.MAGIC_MIME)
                magic_parser.load()
            except:
                magic_parser = False
        if magic_parser:
            mimetype = magic_parser.file(localpath)
            if not mimetype.startswith("image/"):
                print "Problem downloading", localpath
                print "Type:", mimetype
                # Opencyclemap, at least, sometimes serves text files
                # that say "tile not available". Other servers may serve
                # HTML files. If it's text, give the user a chance to see it.
                if mimetype.startswith("text/"):
                    with open(localpath, 'r') as errfile:
                        errstr = errfile.read()
                    # Don't show more than three full lines of error message:
                    if len(errstr) > 240:
                        errstr = errstr[0:100]
                    print 'File contents: "%s"' % errstr.strip()
                else:
                    print "File type is", mimetype

                # Return no local path, so it can be deleted if appropriate.
                return None

        return localpath

    path = yield threaded_task(download, url, localpath, callback)
    if Debug:
        print >>sys.stderr, "[downloaded %s]" % (localpath)
    callback(path)

if __name__ == "__main__":
    p = PyTopo()
    p.main(sys.argv)

